[{"categories":null,"content":"cool文化","date":"2022-02-10","objectID":"/cool/","tags":null,"title":"今天的你Cool嘛","uri":"/cool/"},{"categories":null,"content":"Amazon 创始人杰夫·贝索斯认为很酷 Rudeness is cool. 野蛮不酷 Defeating tiny guys is not cool. 打败弱者不酷 Close-following is not cool. 跟随别人不酷 Young is cool. 年青很酷 Risk taking is cool. 冒险很酷 Winning is cool. 胜利很酷 Polite is cool. 有礼貌很酷 Defeating bigger, unsympathetic guys is cool. 打败不值得同情的大公司很酷 Inventing is cool. 创新很酷 Explorers are cool. 开拓很酷 Conquerors are not cool. 征服不酷 Obsessing over competitors is not cool. 关注竞争对手不酷 Empowering others is cool. 帮助别人很酷 Capturing all the value only for the company is not cool. 复制别人不酷 Leadership is cool. 引领别人很酷 Conviction is cool. 有坚定的信仰很酷 Straightforwardness is cool. 直率很酷 Pandering to the crowd is not cool. 迎合大众不酷 Hypocrisy is not cool. 虚假不酷 Authenticity is cool. 诚实很酷 hinking big is cool. 着眼长远很酷 The unexpected is cool. 意想不到很酷 Missionaries are cool. 传教士很酷 Mercenaries are not cool. 雇佣兵不酷 来源：What Jeff Bezos Thinks Is Cool ","date":"2022-02-10","objectID":"/cool/:0:0","tags":null,"title":"今天的你Cool嘛","uri":"/cool/"},{"categories":["笔记"],"content":"Google 评分卡、Google SRE自评技术或技能领域","date":"2023-09-25","objectID":"/googlescorecard/","tags":["content","Markdown"],"title":"Google 评分卡","uri":"/googlescorecard/"},{"categories":["笔记"],"content":"Google 评分卡 0 - 对于相关的技术领域还不熟悉 1 - 可以读懂这个领域的基础知识 2 - 可以实现一些小的改动、清楚基本原理，并能够在简单的指导下自己找到更多的细节 3 - 基本精通这个技术领域，完全不需要别人的帮助 4 - 对这个技术领域非常熟悉和舒适，可以应对和完成所有的日常工作 对于软件领域: 有能力开发中等规模的程序，能够熟练和掌握并使用所有语言特性，而不是需要翻书，并且能够找到所有的冷知识 对于系统领域：掌握网络和系统管理的很多知识，并能够掌握一些内核知识以运维一个小型网络系统，包括恢复、调试和能解决一些不常见的故障 5 - 对于该技术领域有非常底层的了解和深入的技能 6 - 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构 7- 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作 8 - 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施 9 - 能够在该技术领域出一本经典的书，并和标准委员会的人一起工作制定相关技术标准和方法 10 - 在该领域写过一本书，被业界尊为专家，并是该技术的发明人 ","date":"2023-09-25","objectID":"/googlescorecard/:1:0","tags":["content","Markdown"],"title":"Google 评分卡","uri":"/googlescorecard/"},{"categories":["笔记"],"content":"Google SRE自评技术或技能领域 TCP/IP Networking（OSI stack,DNS etc） Unix/Linux internals Unix/Linux Systems administration Algorithms and Data Structures C/C++ Python Java Perl Go Shell Scripting（sh,Bash,ksh,csh） SQL and/or Database Admin Scripting language of your choice（not already mentioned）_________ People Management Project Management ","date":"2023-09-25","objectID":"/googlescorecard/:2:0","tags":["content","Markdown"],"title":"Google 评分卡","uri":"/googlescorecard/"},{"categories":["笔记"],"content":"The Learning Pyramid ","date":"2023-09-25","objectID":"/googlescorecard/:3:0","tags":["content","Markdown"],"title":"Google 评分卡","uri":"/googlescorecard/"},{"categories":["Google Search"],"content":"Google","date":"2025-01-04","objectID":"/googlesearch/","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"Google 搜索技巧 ","date":"2025-01-04","objectID":"/googlesearch/:1:0","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"1. 基础搜索运算符 精确匹配搜索 - 引号 \"\" 当你需要搜索完全匹配的词组时使用 例如： \"最好的编程语言\" - 完整匹配这个短语 \"python error\" - 精确匹配错误信息 \"how to\" \"python\" - 组合多个精确匹配 适用场景： 搜索特定的错误信息 查找精确的引用或句子 寻找特定的标题或名称 搜索特定的代码片段 使用技巧： 可以组合多个引号搜索 引号内的空格会被保留 标点符号最好也包含在内 排除特定词 - 减号 - 在关键词前加减号可以排除包含该词的结果 实例： java -咖啡 (搜索Java编程而非咖啡) python -蛇 -宠物 (编程相关) 苹果 -手机 -水果 (公司相关) 使用技巧： 减号必须紧贴要排除的词 可以同时使用多个减号 可以排除特定网站：python -site:csdn.com 可以排除特定文件类型：教程 -filetype:pdf 常见应用： 去除购物网站：-site:taobao.com -site:jd.com 去除视频站点：-site:bilibili.com -site:youtube.com 排除培训广告：-培训 -招生 -报名 站内搜索 - site: 限定在特定网站内搜索内容 基本语法：site:网站域名 搜索词 实例： site:zhihu.com 人工智能 site:edu.cn 论文 site:gov.cn 政策 高级用法： 指定多个站点： site:(github.com OR stackoverflow.com) python错误 限定子域名： site:docs.python.org 教程 site:help.github.com 指南 组合其他运算符： site:edu.cn filetype:pdf \"机器学习\" site:github.com \"README.md\" \"最佳实践\" 实用技巧： 学术搜索：site:edu.cn OR site:ac.cn 官方文档：site:docs.*.com 技术问答：site:(stackoverflow.com OR github.com) 政府文件：site:gov.cn filetype:pdf ","date":"2025-01-04","objectID":"/googlesearch/:1:1","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"2. 高级搜索技巧 文件类型搜索 - filetype: 搜索特定格式的文件 常用文件类型： filetype:pdf - PDF文档 filetype:ppt - 演示文稿 filetype:doc - Word文档 filetype:xls - Excel表格 filetype:txt - 文本文件 filetype:zip - 压缩文件 实例： filetype:pdf python教程 site:edu.cn filetype:ppt 项目管理 filetype:doc 简历模板 高级用法： 多文件类型：(filetype:doc OR filetype:pdf) 开发文档 排除某类文件：开发文档 -filetype:pdf 组合站点搜索：site:github.com filetype:md README 通配符搜索 - * 用星号代替任意文字 使用场景： 记不清完整词句时 搜索变体形式 查找特定模式 例子： 如何成为一名*工程师 * 的使用方法 2024年*趋势 高级应用： 歌词搜索：\"我爱* 就像*\" 成语搜索：\"一* 一*\" 标题匹配：\"如何提高* 效率\" 多关键词搜索 - OR 或 | 搜索多个可能的关键词 使用大写的OR或竖线符号 实例： 前端 OR 后端 开发 Python | Java | C++ 教程 可以组合多个条件： (Python | Java) site:github.com (北京 | 上海 | 深圳) 招聘 标题搜索 - intitle: 和 allintitle: intitle: - 搜索标题中包含特定词的页面 allintitle: - 搜索标题中包含所有指定词的页面 使用方法： intitle:python 教程 - 标题含\"python\" allintitle:python 入门 教程 - 标题同时含这三个词 实用场景： 找教程：intitle:教程 python 找文档：intitle:documentation react 找视频：intitle:视频教程 golang 网址搜索 - inurl: 和 allinurl: inurl: - URL中包含特定词 allinurl: - URL中包含所有指定词 应用示例： inurl:blog python - URL含\"blog\" allinurl:github python project 实用技巧： 找博客：inurl:blog site:medium.com 找项目：inurl:project site:github.com 找文档：inurl:docs python 正文内容搜索 - intext: 和 allintext: intext: - 正文中包含特定词 allintext: - 正文中包含所有指定词 使用场景： intext:机器学习 算法 allintext:python 错误 解决方案 组合应用： intext:面试题 site:zhihu.com allintext:源码分析 site:github.com 相关词搜索 - related: 和 AROUND(n) related: - 查找相关网站 AROUND(n) - 查找两个词距离在n个词以内的结果 实例： related:python.org - Python相关网站 python AROUND(3) 教程 - 两词相距3个词内 实用场景： 寻找替代网站：related:stackoverflow.com 寻找相近内容：javascript AROUND(5) framework 时间和数字范围搜索 数字范围 ..： 手机 3000..5000 元 显示器 24..32 英寸 2020..2024 技术趋势 时间范围： before:2024-01-01 - 某日期之前 after:2023-01-01 - 某日期之后 组合示例： after:2023-01-01 before:2024-01-01 编程语言排行 after:2024 site:github.com \"machine learning\" ","date":"2025-01-04","objectID":"/googlesearch/:1:2","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"3. 实用搜索命令 计算和单位转换 数学计算： 基础运算：2 * 3 + 4 高级计算： sin(30) + cos(60) sqrt(144) 2^10 (15% of 80) * 2 log(1000) 5! 单位换算： 货币：100 USD to CNY 长度：5 miles to km 面积：100 平方米 to 平方英尺 重量：50 公斤 转 磅 温度：32F to C 时间和日期查询 时区转换： 北京时间 3pm in New York Tokyo time in London 日期计算： Easter 2024 days between 2024-01-01 and 2024-12-31 weeks until Christmas 日出日落：sunrise/sunset [城市名] 节假日：[节日名] [年份] 实时信息查询 天气信息： 天气 [城市名] [城市]未来一周天气 weather alerts [地区] 交通状态： flight [航班号] [城市]实时路况 自然灾害： earthquakes near [地点] 台风实时路径 股票市场： [股票代码] stock [公司名] stock price 健康相关查询 营养成分： calories in apple protein in chicken breast 运动消耗： calories burned running 30 minutes calories walking 5km BMI计算： BMI calculator healthy weight for 175cm 实用工具命令 IP地址查询： what is my ip ip location 8.8.8.8 网站状态： is facebook down site status github.com 字符计数： word count \"your text here\" character count \"测试文本\" 娱乐功能 掷骰子： roll a die roll 2d6 随机数： random number 1-100 random number generator 游戏： play pacman play snake play solitaire 紧急信息查询 天气预警： weather alerts near me 台风实时路径 地震信息： earthquakes near me recent earthquakes in Japan 急救信息： first aid for burns CPR steps ","date":"2025-01-04","objectID":"/googlesearch/:1:3","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"4. 搜索技巧组合使用 实例一：学术研究 论文搜索组合： site:edu.cn filetype:pdf \"机器学习\" after:2023 -\"课程设计\" 这个组合可以： 限定在教育网站搜索 只搜索PDF格式 精确匹配\"机器学习\" 限定2023年后的内容 排除课程设计类文档 实例二：技术问题排查 错误信息搜索： site:(stackoverflow.com OR github.com) \"RuntimeException\" \"解决方案\" after:2023 搜索策略： 在主流技术社区中搜索 精确匹配错误信息 查找最新的解决方案 支持中英文混合查询 实例三：产品调研 产品评测搜索： (小米 OR 华为) 手机 15000..20000 评测 -二手 filetype:pdf after:2024-01 搜索要点： 指定多个品牌 设定价格范围 排除二手信息 限定最新评测 专业评测文档 实例四：编程资源查找 开发文档搜索： site:github.com \"React Native\" (tutorial OR 教程) stars:\u003e1000 after:2023 搜索特点： 在GitHub上搜索 查找高质量教程 限定星标数量 确保资源新鲜度 实例五：求职信息搜索 工作机会搜索： site:(linkedin.com OR zhipin.com) (\"前端开发\" OR \"前端工程师\") (React OR Vue) 深圳 after:2024 搜索策略： 多平台组合 职位名称变体 技术栈要求 地理位置限定 时间限制 参考资料： 文章资料： 36 Google Search tricks to find exactly what you’re looking for How to Google like a Pro – 10 Tips for More Effective Googling Maximize Your Google Search Skills: 10 Surprising Tricks 视频资料 Google Like a Pro – All Advanced Search Operators Tutorial [2023 Tips] https://www.youtube.com/watch?v=C-2YMhMu5Lc\u0026ab_channel=Dave%27sGarage ","date":"2025-01-04","objectID":"/googlesearch/:1:4","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["计算机系统课程"],"content":"计算机系统课程","date":"2025-01-26","objectID":"/suchen/","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"左耳朵耗子叔公司小伙伴个人成长经历分享整 【非计算机专业的人如何转行程序员】- 宿琛 视频 bilibili YouTube 公开课资源 1、coursera 课程 2、edx 课程 美国四大计算机名校课程 名校CS课程搜索 Google 检索关键词： Stanford/CMU/MIT/UCB + OS/DB/Networking 1、斯坦福大学 (Stanford University)[https://cs.stanford.edu/] 2、麻省理工大学 (Massachusetts Institute of Technology)[https://www.eecs.mit.edu/research/computer-science/] 3、加州大学 (University of California, Berkeley)[https://www2.eecs.berkeley.edu/Courses/CS/] 4、卡内基梅隆大学 (Carnegie Mellon University)[https://www.cs.cmu.edu/] 个人推荐课程 1、composing programs 2、The Missing Semester of Your CS Education 3、Coursera Data Structures And Algorithms Specialization 课程 4、csapp cmu intro to computer science 5、CMU 15-445/645 Intro to Database Systems 6、MIT 6.S081 7、Stanford CS 144 Introduction to Computer Networking 8、MIT 6.824 分布式系统 推荐书籍 1、精力管理 2、成功，动机与目标 3、深度工作 4、学习之道 ","date":"2025-01-26","objectID":"/suchen/:0:1","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"自学计算机系统课程资源 CS自学指南 CS自救指北 哈佛大学免费的在线课程 MIT的 Introduction to Deep Learning 哈佛大学的 CS 50 斯坦福 cs25 Edx.org上的各大名校的公开课程 小林 x 图解计算机基础 斯坦福大学提供的免费认证课程: Designing Your Career 规划你的职业生涯 Computer Science 101 计算机科学101入门 Algorithms: Design and Analysis, Part 1 算法：设计与分析，第 1 部分 Algorithms: Design and Analysis, Part 2 算法：设计与分析，第 2 部分 Computer and Network Security 计算机和网络安全 Computer Organization and Systems 计算机组成与系统 Databases: Advanced Topics in SQL 数据库：SQL的高级主题 Advanced Cybersecurity Program 高级网络安全课程 Machine Learning Specialization 机器学习专项课程 Introduction to Internet of Things 物联网简介 Introduction to Game Theory 博弈论导论 Introduction to Cryptography 密码学入门 Compilers 编译器入门课程 ","date":"2025-01-26","objectID":"/suchen/:0:2","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"免费的编程中文书籍索引 免费的编程中文书籍索引 ","date":"2025-01-26","objectID":"/suchen/:0:3","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"Teach Yourself Computer Science Teach Yourself Computer Science ","date":"2025-01-26","objectID":"/suchen/:0:4","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"计算机网络 (中科大郑烇、杨坚) 《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》 ","date":"2025-01-26","objectID":"/suchen/:0:5","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"计算机网络 (Ivan Velichko) 图文并茂的计算机网络基础:Computer Networking Fundamentals ","date":"2025-01-26","objectID":"/suchen/:0:6","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"Every Programmer Should Know 🤔 Every Programmer Should Know:包括计算机科学、算法数据结构、分布式、正则、安全、可用性、代码设计、工程哲学等 ","date":"2025-01-26","objectID":"/suchen/:0:7","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"操作系统：设计与实现 (南京大学-蒋炎岩) 视频课程–操作系统：设计与实现 2023 课程主页（含讲义） 视频课程–操作系统：设计与实现 2022 ","date":"2025-01-26","objectID":"/suchen/:0:8","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"深入架构原理与实践 深入架构原理与实践 ","date":"2025-01-26","objectID":"/suchen/:0:9","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["科技新闻"],"content":"科技新闻","date":"2025-02-16","objectID":"/technologynews/","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"综合科技新闻 Ars Technica – 深入的科技分析，涵盖计算机、科学、汽车等多个领域。 The Verge – 关注消费电子、互联网趋势和新兴科技产品。 TechCrunch – 重点报道初创企业、科技融资、硅谷动态。 Wired – 深入探讨科技对社会的影响，涵盖人工智能、网络安全等领域。 MIT Technology Review – 由麻省理工学院发布，权威科技趋势分析。 **Slashdot– 一个科技新闻聚合网站，用户可以提交和评论新闻，涵盖广泛的科技话题，适合社区互动和讨论。 **The Next Web – 一个科技新闻聚合网站，用户可以提交和评论新闻，涵盖广泛的科技话题，适合社区互动和讨论。 **ZDNet– 关注企业级科技和 IT 行业动态，提供商业科技新闻和分析。 **Techmeme – 一个专注于科技新闻的聚合网站，被称为“科技新闻界的头版”。它通过自动化算法和人工编辑相结合的方式，实时收集和筛选全球范围内的科技新闻、博客文章和社交媒体讨论。 **Engadget – 一家专注于消费电子和科技产品的新闻网站，提供最新的科技新闻、产品评测和行业分析。 ","date":"2025-02-16","objectID":"/technologynews/:0:1","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"编程 \u0026 开发者 Hacker News – 由 Y Combinator 运营，程序员和创业者必看的社区新闻。 Smashing Magazine – 主要关注前端开发、UI/UX 设计。 InfoQ – 软件开发趋势、架构、云计算等领域的专业报道。 ","date":"2025-02-16","objectID":"/technologynews/:0:2","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"科技商业 \u0026 互联网 Bloomberg Technology – 重点关注科技行业的商业动态、公司战略。 Recode by Vox – 深度分析互联网科技企业，如苹果、谷歌、Meta。 CNBC Technology – 关注科技股、市场变动、投资热点。 ","date":"2025-02-16","objectID":"/technologynews/:0:3","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"前沿科技 \u0026 科学探索 Futurism – 关注前沿科技、太空探索、未来趋势。 New Scientist – 深入报道科学与科技的新发现。 Singularity Hub – 关注人工智能、纳米科技、未来医学等突破性技术。 Science Daily – 科学技术新闻，包括生物科技、太空探索、计算机科学等。 ","date":"2025-02-16","objectID":"/technologynews/:0:4","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"网络安全 \u0026 黑客技术 Krebs on Security – 网络安全专家 Brian Krebs 的博客，深入分析网络安全事件。 Dark Reading – 关注网络攻击、漏洞分析、企业安全技术。 Threatpost – 专注于网络安全威胁、漏洞、数据泄露的最新资讯。 ","date":"2025-02-16","objectID":"/technologynews/:0:5","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"AI \u0026 机器学习 AI News – 专注于人工智能领域的最新发展。 Towards Data Science – 机器学习、数据科学的深入讨论和实践经验。 Robohub – 机器人技术、自动化、人工智能研究的最新进展。 IEEE Robotics \u0026 Automation – 机器人学领域的权威资源。 The Robot Report – 机器人产业新闻、产品评测、技术趋势。 ","date":"2025-02-16","objectID":"/technologynews/:0:6","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"电子硬件 \u0026 半导体 \u0026 未来科技 AnandTech – 专注于芯片、处理器、存储设备等硬件评测。 Tom’s Hardware – 计算机硬件、DIY 组装、评测的优质来源。 IEEE Spectrum – 来自 IEEE，涵盖工程、机器人、半导体等前沿科技。 Futurism – 关注前沿科技、太空探索、未来趋势。 New Scientist – 深入报道科学与科技的新发现。 Singularity Hub – 关注人工智能、纳米科技、未来医学等突破性技术。 Science Daily – 科学技术新闻，包括生物科技、太空探索、计算机科学等。 ","date":"2025-02-16","objectID":"/technologynews/:0:7","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"区块链 \u0026 Web3 CoinDesk – 全球领先的加密货币、区块链新闻站点。 The Block – 提供加密行业的深度报道和研究分析。 Decrypt – 关注 Web3、NFT、去中心化金融（DeFi）等技术发展。 ","date":"2025-02-16","objectID":"/technologynews/:0:8","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"自动驾驶 \u0026 未来交通 Electrek – 关注电动汽车（特斯拉）、可再生能源、自动驾驶。 InsideEVs – 提供电动车市场分析、充电技术进展等资讯。 The Drive – 报道汽车科技、无人驾驶、智能交通等前沿趋势。 ","date":"2025-02-16","objectID":"/technologynews/:0:9","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"生物科技 \u0026 医疗创新 STAT News – 关注生物科技、医药研发、健康科技。 Medgadget – 医疗设备、AI 医疗、可穿戴健康科技的前沿报道。 GenomeWeb – 专注于基因组学、生物信息学、精准医疗等领域。 你对哪个方向的内容最感兴趣？可以深入推荐更专业的资源！ 😊 ","date":"2025-02-16","objectID":"/technologynews/:0:10","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["AI工具","技术笔记"],"content":"全面的AI工具使用指南：从基础对话到高级应用，涵盖编程、写作、设计等各个领域的AI工具推荐和使用技巧。","date":"2025-06-10","objectID":"/ai/","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":" 📝 前言：这是我在使用各种AI工具过程中积累的经验总结，希望能帮助大家更好地利用AI提升工作效率。文章会持续更新，记录最新的工具和使用技巧。 ","date":"2025-06-10","objectID":"/ai/:0:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🤖 AI对话工具详解 ","date":"2025-06-10","objectID":"/ai/:1:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"ChatGPT 系列 ⭐⭐⭐⭐⭐ 官网：https://chat.openai.com 版本对比 GPT-4o：最新版本，多模态能力强，图文并茂 GPT-4：逻辑推理能力最强，适合复杂任务 GPT-3.5：响应速度快，适合日常对话 我的使用心得 💡 最佳实践： 1. 开始对话时先设定角色和背景 2. 复杂任务分解成多个步骤 3. 提供具体例子而非抽象描述 4. 善用\"请继续\"来获取完整回答 实用场景示例 场景一：代码Review 提示词：请以高级程序员的身份，review这段Python代码，重点关注性能优化和安全性问题... 场景二：文案创作 提示词：你是一个资深的新媒体运营，请为我写一篇关于AI工具的推广文案，目标用户是程序员... 场景三：学习助手 提示词：我正在学习机器学习，请用通俗易懂的方式解释什么是神经网络... ","date":"2025-06-10","objectID":"/ai/:1:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Claude 系列 ⭐⭐⭐⭐⭐ 官网：https://claude.ai 核心优势 📖 长文本处理：可以处理100K+ token的文档 🛡️ 安全性高：拒绝生成有害内容 📄 文档分析：支持上传PDF、Word等格式 适用场景 学术论文分析和总结 长篇代码review和重构建议 法律文档、合同条款解读 复杂业务逻辑梳理 ","date":"2025-06-10","objectID":"/ai/:1:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Google Gemini ⭐⭐⭐⭐ 官网：https://gemini.google.com 核心特色 🔍 Google生态集成：与Gmail、Drive、YouTube等服务深度集成 🖼️ 多模态能力：图像分析、文档理解、代码生成 🌍 实时信息：可以搜索最新的网络信息 📱 移动端优化：Android设备原生集成 版本对比 Gemini Ultra：最强性能，与GPT-4竞争 Gemini Pro：平衡性能与成本 Gemini Nano：轻量级，适合移动设备 使用场景 💡 最佳应用场景： - Google Workspace办公自动化 - YouTube视频内容分析 - Android应用开发辅助 - 实时信息查询和分析 - 多语言翻译和本地化 ","date":"2025-06-10","objectID":"/ai/:1:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Grok ⭐⭐⭐⭐ 官网：https://grok.com (需要X Premium订阅) 独特优势 🐦 X平台集成：直接访问X(Twitter)实时数据 😄 幽默风格：具有独特的个性和幽默感 📈 实时资讯：基于X平台的最新信息和趋势 🔓 相对开放：在某些话题上比其他AI更直接 核心功能 🎯 主要特色： 1. 实时热点分析：基于X平台的趋势数据 2. 社交媒体洞察：分析推文和用户行为 3. 新闻事件追踪：快速获取最新资讯 4. 个性化对话：带有马斯克式的幽默风格 使用建议 适合人群：社交媒体运营、新闻工作者、趋势分析师 主要用途：实时信息获取、社交媒体分析、创意写作 注意事项：需要X Premium会员，回答风格较为直接 ","date":"2025-06-10","objectID":"/ai/:1:4","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"国产AI工具对比 工具 优势 适用场景 免费额度 文心一言 中文理解好，百度生态 中文内容创作 每日20次 通义千问 阿里云集成，企业友好 商业应用 每日10次 讯飞星火 语音交互强 语音转文字 每日5次 智谱清言 开源友好 技术研究 每日15次 ","date":"2025-06-10","objectID":"/ai/:1:5","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"💻 AI编程工具实战 ","date":"2025-06-10","objectID":"/ai/:2:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"GitHub Copilot ⭐⭐⭐⭐⭐ 价格：$10/月（学生免费） 进阶使用技巧 注释驱动开发 # 创建一个函数，实现二分查找算法 # 参数：有序数组arr，目标值target # 返回：目标值的索引，如果不存在返回-1 def binary_search(arr, target): # Copilot会自动生成完整实现 测试用例生成 def fibonacci(n): if n \u003c= 1: return n return fibonacci(n-1) + fibonacci(n-2) # 为上面的函数生成测试用例 def test_fibonacci(): # Copilot会生成多个测试场景 代码重构建议 选中代码块，Copilot会提供优化建议 支持多种编程语言和框架 ","date":"2025-06-10","objectID":"/ai/:2:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Cursor ⭐⭐⭐⭐⭐ 官网：https://cursor.sh 独特功能 Ctrl+K：自然语言编程 Ctrl+L：与代码库对话 代码补全：比Copilot更精准的上下文理解 实际使用案例 我的使用场景： 1. 快速生成React组件 2. 代码重构和优化 3. 错误调试和修复 4. API文档生成 ","date":"2025-06-10","objectID":"/ai/:2:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"其他编程AI工具 Tabnine 特点：本地运行，保护代码隐私 适合：企业用户，对安全性要求高 Replit AI 特点：在线IDE + AI辅助 适合：快速原型开发、教学演示 CodeWhisperer (AWS) 特点：AWS服务集成度高 适合：云原生应用开发 ","date":"2025-06-10","objectID":"/ai/:2:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🎨 AI创意工具 ","date":"2025-06-10","objectID":"/ai/:3:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"图像生成工具对比 工具 优势 价格 推荐指数 Midjourney 艺术感强，质量高 $10-60/月 ⭐⭐⭐⭐⭐ DALL-E 3 文字理解准确 $20/月 ⭐⭐⭐⭐ Stable Diffusion 开源免费，可定制 免费 ⭐⭐⭐⭐ Firefly Adobe生态集成 $20/月 ⭐⭐⭐ Midjourney进阶提示词 基础结构：[主题] + [风格] + [参数] 实用模板： - 人像摄影：portrait of [描述], professional photography, studio lighting --ar 3:4 - 产品设计：modern [产品] design, minimalist, white background --ar 1:1 - 概念艺术：[概念] concept art, digital painting, detailed --ar 16:9 高级参数： --ar 16:9 # 宽高比 --v 6 # 版本 --stylize 100 # 风格化程度 --chaos 20 # 随机性 ","date":"2025-06-10","objectID":"/ai/:3:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"视频生成工具 Runway ML 功能：AI视频生成和编辑 特色：Gen-3 Alpha模型，质量接近专业水准 使用场景：短视频制作、广告素材 Pika Labs 功能：文本/图片转视频 特色：操作简单，效果自然 适合人群：内容创作者、社交媒体运营 ","date":"2025-06-10","objectID":"/ai/:3:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"✍️ AI写作工具深度评测 ","date":"2025-06-10","objectID":"/ai/:4:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"长文写作工具 Notion AI 集成优势： 无缝融入工作流 支持多种内容格式 团队协作友好 实用功能： 1. 文章大纲生成：/ai 帮我写一个关于AI工具的文章大纲 2. 内容扩写：选中文字，要求AI扩展内容 3. 语言优化：改善文字表达和语法 4. 格式调整：转换文档格式和风格 Jasper AI 定位：营销文案专家 模板：50+ 营销场景模板 适合：电商、广告、社交媒体 Copy.ai 特色：多语言支持 功能：邮件营销、社交媒体文案 价格：免费版可用，付费$36/月 ","date":"2025-06-10","objectID":"/ai/:4:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"学术写作助手 Grammarly ⭐⭐⭐⭐⭐ 功能亮点： ✅ 语法检查：实时发现并修正错误 ✅ 风格建议：提升文章可读性 ✅ 抄袭检测：确保内容原创性 ✅ 语调分析：调整文章语气 DeepL Write 优势：多语言写作优化 适合：非英语母语用户 功能：句式优化、用词建议 ","date":"2025-06-10","objectID":"/ai/:4:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🚀 提示词工程进阶 ","date":"2025-06-10","objectID":"/ai/:5:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"高级提示词框架 CRISPE 框架 C - Context (上下文)：提供背景信息 R - Role (角色)：指定AI扮演的角色 I - Intent (意图)：明确任务目标 S - Situation (情况)：描述具体场景 P - Product (产品)：定义期望输出 E - Example (示例)：给出参考例子 实际应用案例 【Context】我是一家初创公司的产品经理 【Role】请你作为资深的产品架构师 【Intent】帮我设计一个AI客服系统的产品方案 【Situation】公司有100名员工，日处理客服咨询500+条 【Product】输出包含功能模块、技术架构、实施计划的完整方案 【Example】参考类似ChatBot的设计思路，但要突出我们的差异化优势 ","date":"2025-06-10","objectID":"/ai/:5:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"专业领域提示词库 编程领域 # 代码审查提示词 \"\"\" 请以资深架构师的角度审查以下代码： 1. 代码质量和规范性 2. 性能优化建议 3. 安全性问题 4. 可维护性改进 请提供具体的修改建议和示例代码。 \"\"\" # 算法解析提示词 \"\"\" 请用以下方式解释这个算法： 1. 算法思路（用通俗语言） 2. 时间复杂度分析 3. 空间复杂度分析 4. 适用场景和局限性 5. 代码实现（注释详细） \"\"\" 内容创作 # 文章写作提示词 你是一位专业的科技记者，请按照以下结构写一篇文章： **文章要求：** - 标题：吸引眼球，包含关键词 - 导语：100字内概括核心观点 - 正文：逻辑清晰，数据支撑 - 结尾：总结观点，引发思考 **写作风格：** - 语言简洁明了 - 多用具体数据和案例 - 避免技术术语堆砌 ","date":"2025-06-10","objectID":"/ai/:5:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Chain of Thought (思维链) 技巧 复杂问题分解 请一步步分析这个商业问题： 步骤1：问题定义 - 明确核心问题是什么 - 涉及哪些关键因素 步骤2：信息收集 - 需要哪些数据支撑 - 现有信息的可靠性 步骤3：方案设计 - 列出3个可行方案 - 分析每个方案的优缺点 步骤4：风险评估 - 识别潜在风险点 - 制定应对策略 步骤5：实施计划 - 制定具体时间表 - 分配资源和责任人 ","date":"2025-06-10","objectID":"/ai/:5:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🎯 AI工具选择策略 ","date":"2025-06-10","objectID":"/ai/:6:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"按使用场景分类 ","date":"2025-06-10","objectID":"/ai/:6:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"主流AI对话工具对比 工具 优势 特色功能 价格 推荐指数 ChatGPT 综合能力强，生态完善 插件系统，代码解释器 $20/月 ⭐⭐⭐⭐⭐ Claude 长文本处理，安全性高 文档分析，代码review $20/月 ⭐⭐⭐⭐⭐ Gemini Google生态，实时搜索 多模态，移动端集成 $20/月 ⭐⭐⭐⭐ Grok 实时资讯，个性化对话 X平台数据，幽默风格 $16/月 ⭐⭐⭐⭐ 个人用户推荐 🏠 日常使用组合： - 主力对话：ChatGPT Plus ($20/月) - 编程助手：GitHub Copilot ($10/月) - 写作优化：Grammarly Premium ($12/月) - 图像生成：Midjourney Basic ($10/月) 💰 总成本：$52/月 💡 性价比：⭐⭐⭐⭐⭐ 🌟 进阶组合（多AI工具）： - 主力对话：ChatGPT + Claude ($40/月) - Google生态：Gemini Pro ($20/月) - 实时资讯：Grok (X Premium $16/月) - 编程助手：GitHub Copilot ($10/月) 💰 高级组合总成本：$86/月 🎯 适合：重度AI用户、专业工作者 企业用户推荐 🏢 团队协作组合： - 团队对话：Claude Pro for Teams - 代码管理：GitHub Copilot Business - 文档协作：Notion AI Team - 设计工具：Adobe Firefly Enterprise ⚡ 重点考虑： - 数据安全和隐私保护 - 团队协作和权限管理 - API接入和定制开发 - 成本控制和使用监控 ","date":"2025-06-10","objectID":"/ai/:6:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"免费工具组合 零成本起步方案 💸 完全免费组合： 1. 对话AI：Claude (免费版) + Gemini (免费版) + 文心一言 2. 编程助手：VS Code + Tabnine (免费版) 3. 写作工具：Grammarly (免费版) + DeepL 4. 图像生成：Stable Diffusion (本地部署) 5. 设计工具：Canva (免费版) 📊 功能覆盖：75%的日常需求 🎯 适合人群：学生、个人爱好者、预算有限用户 💡 免费版限制说明： - Claude：每日有使用次数限制 - Gemini：Google账户即可使用，有一定额度 - Grok：需要X Premium，无免费版 - ChatGPT：GPT-3.5免费，GPT-4需付费 ","date":"2025-06-10","objectID":"/ai/:6:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"⚠️ 使用注意事项与最佳实践 ","date":"2025-06-10","objectID":"/ai/:7:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"数据安全防护 敏感信息分类 🔴 绝对不能输入： - 身份证、银行卡等个人敏感信息 - 公司核心商业机密 - 未公开的产品代码 - 客户隐私数据 🟡 谨慎输入： - 公司内部流程信息 - 正在开发的功能特性 - 团队组织架构 - 业务数据（脱敏后可考虑） 🟢 可以安全输入： - 公开的技术文档 - 学习资料和教程 - 通用的代码片段 - 行业公开信息 隐私保护建议 🛡️ 最佳实践： 1. 使用企业版工具（数据不用于训练） 2. 定期清理对话历史 3. 避免在共享设备上使用 4. 关注各平台隐私政策更新 5. 考虑本地部署开源方案 ","date":"2025-06-10","objectID":"/ai/:7:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"结果验证与质量控制 AI输出质量检查清单 ✅ 代码输出检查： - [ ] 语法正确性 - [ ] 逻辑合理性 - [ ] 性能优化空间 - [ ] 安全漏洞排查 - [ ] 测试用例覆盖 ✅ 文本内容检查： - [ ] 事实准确性验证 - [ ] 逻辑连贯性 - [ ] 语言表达流畅度 - [ ] 原创性（避免抄袭） - [ ] 目标受众适配性 ","date":"2025-06-10","objectID":"/ai/:7:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"持续学习路径 进阶学习资源 📚 推荐学习路径： 初级阶段（1-2个月）： - 掌握基本提示词技巧 - 熟悉主流AI工具界面 - 学会简单的工作流自动化 中级阶段（3-6个月）： - 深入学习提示词工程 - 尝试API集成开发 - 探索多工具组合使用 高级阶段（6个月+）： - 参与开源AI项目 - 开发定制化AI应用 - 成为AI工具布道者 ","date":"2025-06-10","objectID":"/ai/:7:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🔗 实用资源与社区 ","date":"2025-06-10","objectID":"/ai/:8:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"官方学习资源 OpenAI Cookbook - 官方最佳实践 Anthropic Claude Guide - Claude使用指南 Google AI Education - AI基础知识 Microsoft AI School - 企业AI应用 ","date":"2025-06-10","objectID":"/ai/:8:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"中文社区推荐 AI工具集 - 国内AI工具导航 提示词工程指南 - 中文提示词教程 知乎AI话题 - 经验分享讨论 GitHub Awesome AI - 开源项目集合 ","date":"2025-06-10","objectID":"/ai/:8:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"实用工具站点 AI对比平台 - 各AI模型性能对比 提示词库 - 优质提示词分享 AI新闻聚合 - 行业最新动态 ","date":"2025-06-10","objectID":"/ai/:8:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"📝 总结与展望 AI工具正在快速发展，新的工具和功能层出不穷。保持学习的心态，关注行业动态，及时调整工具选择策略，才能在AI时代保持竞争优势。 我的使用原则： 🎯 效率优先：选择最能提升工作效率的工具 💰 成本控制：平衡功能需求与经济成本 🔒 安全第一：始终把数据安全放在首位 📈 持续优化：定期评估和调整工具组合 未来展望： AI工具将更加智能化和个性化 多模态AI（文字+图像+语音）成为主流 企业级AI应用将迎来爆发式增长 AI伦理和监管将日趋完善 最后更新：2025年6月 参考链接：SincereCSL/Playgrounds ChatGPT.md 💡 提示：如果你有更好的AI工具推荐或使用技巧，欢迎在评论区分享交流！ ","date":"2025-06-10","objectID":"/ai/:9:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术深度"],"content":"全面解析MCP（Model Context Protocol）：从架构原理到开发实践，探索AI工具的标准化连接协议","date":"2025-06-15","objectID":"/mcp/","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":" 📝 前言：MCP（Model Context Protocol）是由Anthropic发布的开放标准，旨在标准化AI助手与数据源之间的连接方式。本文将深入解析MCP的架构原理、开发模式和实际应用，帮助开发者理解和使用这一革命性的协议。 ","date":"2025-06-15","objectID":"/mcp/:0:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🎯 什么是MCP？ ","date":"2025-06-15","objectID":"/mcp/:1:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"定义与概念 Model Context Protocol (MCP) 是一个开放的协议标准，它标准化了应用程序向大语言模型（LLM）提供上下文的方式。 形象比喻 如果把MCP比作USB-C接口： USB-C：为设备连接各种外设提供标准化接口 MCP：为AI模型连接不同数据源和工具提供标准化协议 ","date":"2025-06-15","objectID":"/mcp/:1:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"核心价值 🎯 MCP解决的核心问题： 1. 数据孤岛：AI模型被困在信息孤岛中 2. 集成复杂：每个数据源需要定制化实现 3. 扩展困难：连接系统难以规模化 4. 维护成本：碎片化集成难以维护 ","date":"2025-06-15","objectID":"/mcp/:1:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🏗️ MCP架构深度解析 ","date":"2025-06-15","objectID":"/mcp/:2:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"整体架构 MCP采用客户端-服务器架构，支持一个宿主应用连接多个服务器： graph TB Host[MCP Host\u003cbr/\u003e宿主应用] --\u003e Client1[MCP Client 1] Host --\u003e Client2[MCP Client 2] Host --\u003e Client3[MCP Client 3] Client1 --\u003e Server1[MCP Server 1\u003cbr/\u003e文件系统] Client2 --\u003e Server2[MCP Server 2\u003cbr/\u003e数据库] Client3 --\u003e Server3[MCP Server 3\u003cbr/\u003eAPI服务] Server1 --\u003e Data1[本地文件] Server2 --\u003e Data2[PostgreSQL] Server3 --\u003e Data3[外部API] ","date":"2025-06-15","objectID":"/mcp/:2:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"核心组件详解 1. MCP Host（宿主） 🏠 定义：运行AI模型的应用程序 📋 功能： - 管理与多个MCP服务器的连接 - 协调AI模型与外部数据的交互 - 处理用户请求和响应 💡 典型示例： - Claude Desktop - VS Code插件 - 自定义AI应用 2. MCP Client（客户端） 🔌 定义：协议客户端，维护与服务器的1:1连接 📋 功能： - 处理协议通信 - 管理连接状态 - 数据序列化/反序列化 🛠️ 实现方式： - 通常内嵌在Host应用中 - 使用官方SDK开发 - 支持多种传输协议 3. MCP Server（服务器） ⚙️ 定义：轻量级程序，通过标准协议暴露特定能力 📋 功能： - 提供Resources（资源） - 暴露Tools（工具） - 实现Prompts（提示模板） 🌟 特点： - 单一职责原则 - 标准化接口 - 易于部署和维护 ","date":"2025-06-15","objectID":"/mcp/:2:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"通信机制 传输层（Transport） { \"jsonrpc\": \"2.0\", \"method\": \"resources/list\", \"id\": 1, \"params\": {} } MCP支持多种传输方式： 标准输入/输出（stdio） # 启动stdio传输的MCP服务器 import sys import asyncio from mcp.server.stdio import stdio_server async def main(): async with stdio_server() as (read_stream, write_stream): await run_server(read_stream, write_stream) if __name__ == \"__main__\": asyncio.run(main()) HTTP传输 # HTTP传输配置 from mcp.server.fastapi import create_mcp_app from fastapi import FastAPI app = FastAPI() mcp_app = create_mcp_app(MyMcpServer()) app.mount(\"/mcp\", mcp_app) # 启动HTTP服务器 if __name__ == \"__main__\": import uvicorn uvicorn.run(app, host=\"0.0.0.0\", port=8000) WebSocket传输 # WebSocket实时通信 import websockets from mcp.server.websocket import websocket_server async def handle_websocket(websocket, path): async with websocket_server(websocket) as server: await server.run() start_server = websockets.serve(handle_websocket, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) 协议消息格式详解 { \"jsonrpc\": \"2.0\", \"method\": \"initialize\", \"id\": 1, \"params\": { \"protocolVersion\": \"2024-11-05\", \"capabilities\": { \"resources\": { \"subscribe\": true, \"listChanged\": true }, \"tools\": { \"listChanged\": true }, \"prompts\": { \"listChanged\": true }, \"logging\": {}, \"sampling\": {} }, \"clientInfo\": { \"name\": \"example-client\", \"version\": \"1.0.0\" } } } ","date":"2025-06-15","objectID":"/mcp/:2:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"💻 MCP核心概念详解 ","date":"2025-06-15","objectID":"/mcp/:3:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"协议生命周期管理 1. 连接建立流程 sequenceDiagram participant Client participant Server Client-\u003e\u003eServer: initialize request Server-\u003e\u003eClient: initialize response Client-\u003e\u003eServer: initialized notification Note over Client,Server: 连接建立完成 Client-\u003e\u003eServer: resources/list Server-\u003e\u003eClient: resources list response Client-\u003e\u003eServer: tools/list Server-\u003e\u003eClient: tools list response Note over Client,Server: 正常通信阶段 2. 能力协商（Capabilities） class ServerCapabilities: def __init__(self): self.resources = ResourceCapabilities( subscribe=True, # 支持资源订阅 listChanged=True # 支持列表变更通知 ) self.tools = ToolCapabilities( listChanged=True # 支持工具列表变更 ) self.prompts = PromptCapabilities( listChanged=True # 支持提示模板变更 ) self.logging = LoggingCapabilities() # 日志功能 self.sampling = SamplingCapabilities() # 采样功能 # 服务器能力声明 async def handle_initialize(self, params): return InitializeResult( protocolVersion=\"2024-11-05\", capabilities=self.get_capabilities(), serverInfo=ServerInfo( name=\"advanced-mcp-server\", version=\"2.0.0\" ) ) ","date":"2025-06-15","objectID":"/mcp/:3:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"1. Resources（资源）深度解析 定义与作用 Resources是MCP服务器暴露给AI模型的只读数据，可以是文件、数据库记录、API响应等。 资源类型系统 from typing import Union, List, Dict, Any from dataclasses import dataclass from enum import Enum class ResourceType(Enum): TEXT = \"text\" BINARY = \"binary\" JSON = \"json\" XML = \"xml\" CSV = \"csv\" IMAGE = \"image\" AUDIO = \"audio\" VIDEO = \"video\" @dataclass class ResourceMetadata: \"\"\"资源元数据\"\"\" size: int lastModified: str encoding: str language: str = None tags: List[str] = None permissions: Dict[str, bool] = None @dataclass class AdvancedResource: uri: str name: str description: str mimeType: str resourceType: ResourceType metadata: ResourceMetadata annotations: Dict[str, Any] = None 高级资源实现 class AdvancedResourceServer(McpServer): def __init__(self): super().__init__(\"advanced-resource-server\") self.resource_cache = {} self.resource_subscribers = set() async def list_resources(self) -\u003e List[AdvancedResource]: \"\"\"列出所有可用资源\"\"\" resources = [] # 动态扫描文件系统 for file_path in self.scan_directory(\"/data\"): resource = await self.create_resource_from_file(file_path) resources.append(resource) # 数据库资源 db_resources = await self.get_database_resources() resources.extend(db_resources) # API资源 api_resources = await self.get_api_resources() resources.extend(api_resources) return resources async def read_resource(self, uri: str) -\u003e Union[str, bytes]: \"\"\"读取资源内容，支持缓存和压缩\"\"\" # 检查缓存 if uri in self.resource_cache: cache_entry = self.resource_cache[uri] if not self.is_cache_expired(cache_entry): return cache_entry['content'] # 根据URI类型读取资源 if uri.startswith(\"file://\"): content = await self.read_file_resource(uri) elif uri.startswith(\"db://\"): content = await self.read_database_resource(uri) elif uri.startswith(\"api://\"): content = await self.read_api_resource(uri) else: raise ValueError(f\"不支持的资源URI: {uri}\") # 更新缓存 self.resource_cache[uri] = { 'content': content, 'timestamp': time.time(), 'size': len(content) if isinstance(content, str) else len(content) } return content async def subscribe_to_resource(self, uri: str) -\u003e None: \"\"\"订阅资源变更通知\"\"\" self.resource_subscribers.add(uri) # 启动文件监控 await self.start_file_watcher(uri) async def notify_resource_changed(self, uri: str): \"\"\"通知资源变更\"\"\" if uri in self.resource_subscribers: await self.send_notification(\"notifications/resources/updated\", { \"uri\": uri, \"timestamp\": time.time() }) 实现示例 # 文件系统资源服务器 from mcp import McpServer, Resource class FileSystemServer(McpServer): async def list_resources(self): return [ Resource( uri=\"file:///path/to/document.txt\", name=\"项目文档\", description=\"项目的详细说明文档\", mimeType=\"text/plain\" ) ] async def read_resource(self, uri: str): if uri.startswith(\"file://\"): path = uri[7:] # 移除file://前缀 with open(path, 'r', encoding='utf-8') as f: return f.read() 应用场景 📁 文件系统： - 代码文件、文档、配置文件 - 支持多种文件格式（txt, md, json, etc.） 🗄️ 数据库： - 表结构、查询结果 - 支持SQL和NoSQL数据库 🌐 Web资源： - API响应、网页内容 - 实时数据抓取 ","date":"2025-06-15","objectID":"/mcp/:3:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"2. Tools（工具）高级特性 定义与作用 Tools允许AI模型执行操作，如文件写入、API调用、数据库更新等。 工具参数验证系统 from pydantic import BaseModel, validator, Field from typing import Optional, Union, List import jsonschema class AdvancedToolParameter(BaseModel): \"\"\"高级工具参数定义\"\"\" name: str type: str description: str required: bool = True default: Optional[Any] = None enum: Optional[List[str]] = None pattern: Optional[str] = None minimum: Optional[Union[int, float]] = None maximum: Optional[Union[int, float]] = None @validator('type') def validate_type(cls, v): valid_types = ['string', 'number', 'integer', 'boolean', 'array', 'object'] if v not in valid_types: raise ValueError(f'Invalid type: {v}') return v class AdvancedTool(BaseModel): \"\"\"高级工具定义\"\"\" name: str description: str parameters: List[AdvancedToolParameter] examples: Optional[List[Dict[str, Any]]] = None category: str = \"general\" tags: List[str] = [] timeout: int = 30 # 超时时间（秒） retryable: bool = True permissions: List[str] = [] def validate_input(self, arguments: Dict[str, Any]) -\u003e None: \"\"\"验证输入参数\"\"\" schema = self.generate_json_schema() try: jsonschema.validate(arguments, schema) except jsonschema.ValidationError as e: raise ValueError(f\"参数验证失败: {e.message}\") def generate_json_schema(self) -\u003e Dict[str, Any]: \"\"\"生成JSON Schema用于参数验证\"\"\" properties = {} required = [] for param in self.parameters: prop = { \"type\": param.type, \"description\": param.description } if param.enum: prop[\"enum\"] = param.enum if param.pattern: prop[\"pattern\"] = param.pattern if param.minimum is not None: prop[\"minimum\"] = param.minimum if param.maximum is not None: prop[\"maximum\"] = param.maximum if param.default is not None: prop[\"default\"] = param.default properties[param.name] = prop if param.required: required.append(param.name) return { \"type\": \"object\", \"properties\": properties, \"required\": required } 工具执行引擎 import asyncio from contextlib import asynccontextmanager import time from typing import AsyncGenerator class ToolExecutionContext: \"\"\"工具执行上下文\"\"\" def __init__(self, tool_name: str, client_id: str): self.tool_name = tool_name self.client_id = client_id self.start_time = time.time() self.execution_id = f\"{tool_name}_{int(time.time())}\" self.metadata = {} class AdvancedToolServer(McpServer): def __init__(self): super().__init__(\"advanced-tool-server\") self.tool_registry = {} self.execution_history = [] self.concurrent_executions = {} def register_tool(self, tool: AdvancedTool, handler_func): \"\"\"注册工具和处理函数\"\"\" self.tool_registry[tool.name] = { 'tool': tool, 'handler': handler_func } async def list_tools(self) -\u003e List[AdvancedTool]: \"\"\"列出所有注册的工具\"\"\" return [entry['tool'] for entry in self.tool_registry.values()] @asynccontextmanager async def execution_context(self, tool_name: str, client_id: str) -\u003e AsyncGenerator[ToolExecutionContext, None]: \"\"\"工具执行上下文管理器\"\"\" context = ToolExecutionContext(tool_name, client_id) self.concurrent_executions[context.execution_id] = context try: yield context finally: # 记录执行历史 context.end_time = time.time() context.duration = context.end_time - context.start_time self.execution_history.append(context) # 清理并发执行记录 del self.concurrent_executions[context.execution_id] async def call_tool(self, name: str, arguments: dict) -\u003e ToolResult: \"\"\"执行工具调用\"\"\" if name not in self.tool_registry: raise McpError( code=ErrorCode.METHOD_NOT_FOUND, message=f\"工具 '{name}' 未找到\" ) tool_entry = self.tool_registry[name] tool = tool_entry['tool'] handler = tool_entry['handler'] # 参数验证 try: tool.validate_input(arguments) except ValueError as e: raise McpError( code=ErrorCode.INVALID_PARAMS, message=str(e) ) # 权限检查 await self.check_tool_permissions(tool, self.get_current_client_id()) # 执行工具 async with self.execution_context(name, self.get_current_client_id()) as context: try: # 设置超时 result = await asyncio.wait_for( handler(arguments, context), timeout=tool.timeout ) return result except asyncio.TimeoutError: raise McpError( code=ErrorCode.REQUEST_TIMEOUT, message=f\"工具执行超时 ({tool.timeout}秒)\" ) except Exception as e: if tool.retryable: # 可重试的工具进行重试 ","date":"2025-06-15","objectID":"/mcp/:3:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"3. Prompts（提示模板） 定义与作用 Prompts是可重用的提示模板，包含动态参数，用于标准化AI交互模式。 实现示例 from mcp import Prompt, PromptArgument class CodeReviewServer(McpServer): async def list_prompts(self): return [ Prompt( name=\"code_review\", description=\"代码评审提示模板\", arguments=[ PromptArgument( name=\"code\", description=\"要评审的代码\", required=True ), PromptArgument( name=\"language\", description=\"编程语言\", required=False ) ] ) ] async def get_prompt(self, name: str, arguments: dict): if name == \"code_review\": code = arguments[\"code\"] language = arguments.get(\"language\", \"未知\") return f\"\"\" 请对以下{language}代码进行详细评审： 代码内容： ```{language} {code} 请从以下几个方面进行分析： 代码质量和规范性 性能优化建议 安全性问题 可维护性改进 最佳实践建议 请提供具体的修改建议和示例代码。 \"\"\" ## 🔒 MCP安全与中间件系统 ### 认证与授权中间件 #### JWT认证中间件 ```python import jwt from functools import wraps from typing import Dict, Any, Optional class JWTAuthMiddleware: def __init__(self, secret_key: str, algorithm: str = \"HS256\"): self.secret_key = secret_key self.algorithm = algorithm def verify_token(self, token: str) -\u003e Optional[Dict[str, Any]]: \"\"\"验证JWT令牌\"\"\" try: payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm]) return payload except jwt.ExpiredSignatureError: raise McpError(code=ErrorCode.UNAUTHORIZED, message=\"令牌已过期\") except jwt.InvalidTokenError: raise McpError(code=ErrorCode.UNAUTHORIZED, message=\"无效令牌\") def require_permission(self, permission: str): \"\"\"权限装饰器\"\"\" def decorator(func): @wraps(func) async def wrapper(self, *args, **kwargs): client_token = self.get_client_token() payload = self.verify_token(client_token) user_permissions = payload.get('permissions', []) if permission not in user_permissions: raise McpError( code=ErrorCode.PERMISSION_DENIED, message=f\"缺少权限: {permission}\" ) return await func(self, *args, **kwargs) return wrapper return decorator class SecureServer(McpServer): def __init__(self): super().__init__(\"secure-server\") self.auth_middleware = JWTAuthMiddleware(os.getenv(\"JWT_SECRET\")) @auth_middleware.require_permission(\"read:resources\") async def read_resource(self, uri: str): return await super().read_resource(uri) @auth_middleware.require_permission(\"execute:tools\") async def call_tool(self, name: str, arguments: dict): return await super().call_tool(name, arguments) 请求限流中间件 import time from collections import defaultdict, deque from typing import DefaultDict class RateLimiter: def __init__(self, max_requests: int, window_seconds: int): self.max_requests = max_requests self.window_seconds = window_seconds self.requests: DefaultDict[str, deque] = defaultdict(deque) def is_allowed(self, client_id: str) -\u003e bool: \"\"\"检查是否允许请求\"\"\" now = time.time() client_requests = self.requests[client_id] # 清理过期请求 while client_requests and client_requests[0] \u003c= now - self.window_seconds: client_requests.popleft() # 检查请求数量 if len(client_requests) \u003e= self.max_requests: return False # 记录新请求 client_requests.append(now) return True class RateLimitedServer(McpServer): def __init__(self): super().__init__(\"rate-limited-server\") self.rate_limiter = RateLimiter(max_requests=100, window_seconds=60) async def handle_request(self, method: str, params: dict): client_id = self.get_current_client_id() if not self.rate_limiter.is_allowed(client_id): raise McpError( code=ErrorCode.RATE_LIMITED, message=\"请求频率超限，请稍后重试\" ) return await super().handle_request(method, params) ","date":"2025-06-15","objectID":"/mcp/:3:4","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"数据加密与脱敏 字段级加密 from cryptography.fernet import Fernet import base64 import json class FieldEncryption: def __init__(self, encryption_key: bytes): self.cipher_suite = Fernet(encryption_key) def encrypt_field(self, data: str) -\u003e str: \"\"\"加密字段\"\"\" encrypted_data = self.cipher_suite.encrypt(data.encode()) return base64.b64encode(encrypted_data).decode() def decrypt_field(self, encrypted_data: str) -\u003e str: \"\"\"解密字段\"\"\" decoded_data = base64.b64decode(encrypted_data.encode()) decrypted_data = self.cipher_suite.decrypt(decoded_data) return decrypted_data.decode() class DataMasking: \"\"\"数据脱敏工具\"\"\" @staticmethod def mask_email(email: str) -\u003e str: \"\"\"邮箱脱敏\"\"\" if '@' not in email: return email local, domain = email.split('@', 1) masked_local = local[:2] + '*' * (len(local) - 2) return f\"{masked_local}@{domain}\" @staticmethod def mask_phone(phone: str) -\u003e str: \"\"\"电话号码脱敏\"\"\" if len(phone) \u003c 7: return phone return phone[:3] + '*' * (len(phone) - 6) + phone[-3:] @staticmethod def mask_id_card(id_card: str) -\u003e str: \"\"\"身份证脱敏\"\"\" if len(id_card) \u003c 8: return id_card return id_card[:4] + '*' * (len(id_card) - 8) + id_card[-4:] class SecureDataServer(McpServer): def __init__(self): super().__init__(\"secure-data-server\") self.field_encryption = FieldEncryption(Fernet.generate_key()) self.data_masking = DataMasking() async def read_resource(self, uri: str) -\u003e str: \"\"\"读取资源并进行数据脱敏\"\"\" raw_data = await self.load_raw_data(uri) # 根据资源类型进行脱敏 if uri.startswith(\"user://\"): return self.mask_user_data(raw_data) elif uri.startswith(\"sensitive://\"): return self.decrypt_and_mask_data(raw_data) return raw_data def mask_user_data(self, data: str) -\u003e str: \"\"\"用户数据脱敏\"\"\" try: user_data = json.loads(data) if 'email' in user_data: user_data['email'] = self.data_masking.mask_email(user_data['email']) if 'phone' in user_data: user_data['phone'] = self.data_masking.mask_phone(user_data['phone']) if 'id_card' in user_data: user_data['id_card'] = self.data_masking.mask_id_card(user_data['id_card']) return json.dumps(user_data, ensure_ascii=False) except json.JSONDecodeError: return data ","date":"2025-06-15","objectID":"/mcp/:3:5","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🔄 MCP协议扩展 ","date":"2025-06-15","objectID":"/mcp/:4:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"自定义协议扩展 class CustomProtocolExtension: \"\"\"自定义协议扩展\"\"\" def __init__(self, namespace: str): self.namespace = namespace self.custom_methods = {} def register_method(self, method_name: str, handler): \"\"\"注册自定义方法\"\"\" full_method_name = f\"{self.namespace}/{method_name}\" self.custom_methods[full_method_name] = handler async def handle_custom_request(self, method: str, params: dict): \"\"\"处理自定义请求\"\"\" if method in self.custom_methods: return await self.custom_methods[method](params) else: raise McpError( code=ErrorCode.METHOD_NOT_FOUND, message=f\"自定义方法未找到: {method}\" ) class ExtendedServer(McpServer): def __init__(self): super().__init__(\"extended-server\") self.extension = CustomProtocolExtension(\"mycompany\") self.setup_custom_methods() def setup_custom_methods(self): \"\"\"设置自定义方法\"\"\" self.extension.register_method(\"bulk_upload\", self.handle_bulk_upload) self.extension.register_method(\"stream_data\", self.handle_stream_data) self.extension.register_method(\"batch_process\", self.handle_batch_process) async def handle_bulk_upload(self, params: dict): \"\"\"处理批量上传\"\"\" files = params.get('files', []) results = [] for file_info in files: result = await self.upload_single_file(file_info) results.append(result) return { \"uploaded\": len(results), \"results\": results } async def handle_stream_data(self, params: dict): \"\"\"处理流数据\"\"\" stream_id = params.get('stream_id') chunk_size = params.get('chunk_size', 1024) async for chunk in self.get_data_stream(stream_id, chunk_size): yield { \"stream_id\": stream_id, \"chunk\": chunk, \"timestamp\": time.time() } ","date":"2025-06-15","objectID":"/mcp/:4:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"事件驱动架构 import asyncio from typing import Callable, List from dataclasses import dataclass @dataclass class McpEvent: \"\"\"MCP事件\"\"\" type: str data: dict timestamp: float source: str class EventBus: \"\"\"事件总线\"\"\" def __init__(self): self.subscribers: Dict[str, List[Callable]] = defaultdict(list) self.event_history: List[McpEvent] = [] def subscribe(self, event_type: str, handler: Callable): \"\"\"订阅事件\"\"\" self.subscribers[event_type].append(handler) def unsubscribe(self, event_type: str, handler: Callable): \"\"\"取消订阅\"\"\" if handler in self.subscribers[event_type]: self.subscribers[event_type].remove(handler) async def publish(self, event: McpEvent): \"\"\"发布事件\"\"\" self.event_history.append(event) # 通知所有订阅者 handlers = self.subscribers.get(event.type, []) if handlers: await asyncio.gather(*[handler(event) for handler in handlers]) def get_event_history(self, event_type: str = None, limit: int = 100) -\u003e List[McpEvent]: \"\"\"获取事件历史\"\"\" events = self.event_history if event_type: events = [e for e in events if e.type == event_type] return events[-limit:] class EventDrivenServer(McpServer): def __init__(self): super().__init__(\"event-driven-server\") self.event_bus = EventBus() self.setup_event_handlers() def setup_event_handlers(self): \"\"\"设置事件处理器\"\"\" self.event_bus.subscribe(\"resource.created\", self.on_resource_created) self.event_bus.subscribe(\"resource.updated\", self.on_resource_updated) self.event_bus.subscribe(\"tool.executed\", self.on_tool_executed) self.event_bus.subscribe(\"client.connected\", self.on_client_connected) async def on_resource_created(self, event: McpEvent): \"\"\"资源创建事件处理\"\"\" resource_uri = event.data.get('uri') await self.send_notification(\"notifications/resources/created\", { \"uri\": resource_uri, \"timestamp\": event.timestamp }) async def on_tool_executed(self, event: McpEvent): \"\"\"工具执行事件处理\"\"\" tool_name = event.data.get('tool_name') execution_time = event.data.get('duration') # 记录性能指标 await self.record_performance_metric(tool_name, execution_time) # 如果执行时间过长，发送警告 if execution_time \u003e 10: # 10秒 await self.send_notification(\"notifications/performance/warning\", { \"tool\": tool_name, \"duration\": execution_time, \"message\": \"工具执行时间过长\" }) ### 分布式MCP架构 #### 服务发现与负载均衡 ```python import consul import hashlib from typing import List, Dict, Optional class ServiceDiscovery: \"\"\"服务发现\"\"\" def __init__(self, consul_host: str = \"localhost\", consul_port: int = 8500): self.consul = consul.Consul(host=consul_host, port=consul_port) self.service_cache = {} self.cache_ttl = 30 # 缓存30秒 async def register_service(self, service_name: str, host: str, port: int, tags: List[str] = None): \"\"\"注册服务\"\"\" service_id = f\"{service_name}-{host}-{port}\" self.consul.agent.service.register( name=service_name, service_id=service_id, address=host, port=port, tags=tags or [], check=consul.Check.http(f\"http://{host}:{port}/health\", interval=\"10s\") ) async def discover_services(self, service_name: str) -\u003e List[Dict]: \"\"\"发现服务\"\"\" # 检查缓存 cache_key = f\"services:{service_name}\" if cache_key in self.service_cache: cached_data = self.service_cache[cache_key] if time.time() - cached_data['timestamp'] \u003c self.cache_ttl: return cached_data['services'] # 从Consul获取服务列表 _, services = self.consul.health.service(service_name, passing=True) service_list = [] for service in services: service_info = service['Service'] service_list.append({ 'id': service_info['ID'], 'address': service_info['Address'], 'port': service_info['Port'], 'tags': service_info['Tags'] }) # 更新缓存 self.service_cache[cache_key] = { 'services': service_list, 'timestamp': time.time() } return service_list class LoadBalancer: \"\"\"负载均衡器\"\"\" def __init__(self, strategy: str = \"round_robin\"): self.strategy = strategy self.round_robin_index = 0 self.service_weights = {} self.service_health = {} def select_service(self, services: List[Dict], client_id: str = None) -\u003e Optional[Dict]: \"\"\"选择服务实例\"\"\" if not services: return None # 过滤健康的服务 healthy_services = [s for s in services if self.service_health.get(s['id'], True)] if not healthy_services: return No","date":"2025-06-15","objectID":"/mcp/:4:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"云原生部署方案 Kubernetes配置 # mcp-server-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: mcp-server labels: app: mcp-server spec: replicas: 3 selector: matchLabels: app: mcp-server template: metadata: labels: app: mcp-server spec: containers: - name: mcp-server image: myregistry/mcp-server:latest ports: - containerPort: 8000 env: - name: DATABASE_URL valueFrom: secretKeyRef: name: mcp-secrets key: database-url - name: REDIS_URL valueFrom: configMapKeyRef: name: mcp-config key: redis-url resources: requests: memory: \"256Mi\" cpu: \"250m\" limits: memory: \"512Mi\" cpu: \"500m\" livenessProbe: httpGet: path: /health port: 8000 initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: httpGet: path: /ready port: 8000 initialDelaySeconds: 5 periodSeconds: 5 --- apiVersion: v1 kind: Service metadata: name: mcp-server-service spec: selector: app: mcp-server ports: - protocol: TCP port: 80 targetPort: 8000 type: LoadBalancer --- apiVersion: autoscaling/v2 kind: HorizontalPodAutoscaler metadata: name: mcp-server-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: mcp-server minReplicas: 2 maxReplicas: 10 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: memory target: type: Utilization averageUtilization: 80 Helm Chart配置 # values.yaml replicaCount: 3 image: repository: myregistry/mcp-server tag: latest pullPolicy: IfNotPresent service: type: LoadBalancer port: 80 targetPort: 8000 ingress: enabled: true annotations: kubernetes.io/ingress.class: nginx cert-manager.io/cluster-issuer: letsencrypt-prod hosts: - host: mcp-api.example.com paths: - path: / pathType: Prefix tls: - secretName: mcp-api-tls hosts: - mcp-api.example.com autoscaling: enabled: true minReplicas: 2 maxReplicas: 10 targetCPUUtilizationPercentage: 70 targetMemoryUtilizationPercentage: 80 resources: limits: cpu: 500m memory: 512Mi requests: cpu: 250m memory: 256Mi # 配置管理 config: database: url: postgresql://user:pass@postgres:5432/mcpdb pool_size: 20 timeout: 30 redis: url: redis://redis:6379/0 ttl: 3600 monitoring: enabled: true prometheus: enabled: true port: 9090 security: jwt_secret: \"your-secret-key\" cors_origins: - \"https://app.example.com\" - \"https://admin.example.com\" ","date":"2025-06-15","objectID":"/mcp/:4:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"高级调试与诊断工具 MCP协议调试器 import json import asyncio from typing import Dict, List, Any from datetime import datetime class McpProtocolDebugger: \"\"\"MCP协议调试器\"\"\" def __init__(self, enable_trace: bool = True): self.enable_trace = enable_trace self.message_history: List[Dict] = [] self.error_history: List[Dict] = [] self.performance_metrics: Dict[str, List] = {} def trace_message(self, direction: str, message: Dict[str, Any]): \"\"\"跟踪消息\"\"\" if not self.enable_trace: return trace_entry = { 'timestamp': datetime.now().isoformat(), 'direction': direction, # 'incoming' 或 'outgoing' 'message': message, 'size': len(json.dumps(message).encode()) } self.message_history.append(trace_entry) # 保持历史记录大小 if len(self.message_history) \u003e 1000: self.message_history = self.message_history[-1000:] def trace_error(self, error: Exception, context: Dict[str, Any] = None): \"\"\"跟踪错误\"\"\" error_entry = { 'timestamp': datetime.now().isoformat(), 'error_type': type(error).__name__, 'error_message': str(error), 'context': context or {} } self.error_history.append(error_entry) if len(self.error_history) \u003e 100: self.error_history = self.error_history[-100:] def record_performance(self, operation: str, duration: float, metadata: Dict = None): \"\"\"记录性能数据\"\"\" if operation not in self.performance_metrics: self.performance_metrics[operation] = [] performance_entry = { 'timestamp': datetime.now().isoformat(), 'duration': duration, 'metadata': metadata or {} } self.performance_metrics[operation].append(performance_entry) # 保持每个操作最多100条记录 if len(self.performance_metrics[operation]) \u003e 100: self.performance_metrics[operation] = self.performance_metrics[operation][-100:] def get_debug_report(self) -\u003e Dict[str, Any]: \"\"\"生成调试报告\"\"\" report = { 'summary': { 'total_messages': len(self.message_history), 'total_errors': len(self.error_history), 'performance_operations': len(self.performance_metrics) }, 'recent_messages': self.message_history[-10:], 'recent_errors': self.error_history[-5:], 'performance_summary': {} } # 性能摘要 for operation, metrics in self.performance_metrics.items(): if metrics: durations = [m['duration'] for m in metrics] report['performance_summary'][operation] = { 'count': len(durations), 'avg_duration': sum(durations) / len(durations), 'min_duration': min(durations), 'max_duration': max(durations) } return report def export_trace(self, filename: str = None): \"\"\"导出跟踪数据\"\"\" if not filename: filename = f\"mcp_trace_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\" trace_data = { 'messages': self.message_history, 'errors': self.error_history, 'performance': self.performance_metrics, 'exported_at': datetime.now().isoformat() } with open(filename, 'w', encoding='utf-8') as f: json.dump(trace_data, f, ensure_ascii=False, indent=2) return filename class DebuggableMcpServer(McpServer): \"\"\"可调试的MCP服务器\"\"\" def __init__(self, name: str, debug_mode: bool = False): super().__init__(name) self.debug_mode = debug_mode self.debugger = McpProtocolDebugger(enable_trace=debug_mode) self.request_id_counter = 0 async def handle_request(self, method: str, params: dict): \"\"\"处理请求（带调试功能）\"\"\" self.request_id_counter += 1 request_id = f\"req_{self.request_id_counter}\" start_time = time.time() # 跟踪入站消息 if self.debug_mode: self.debugger.trace_message('incoming', { 'id': request_id, 'method': method, 'params': params }) try: result = await super().handle_request(method, params) # 跟踪出站响应 if self.debug_mode: self.debugger.trace_message('outgoing', { 'id': request_id, 'result': result }) return result except Exception as e: # 跟踪错误 self.debugger.trace_error(e, { 'request_id': request_id, 'method': method, 'params': params }) # 跟踪错误响应 if self.debug_mode: self.debugger.trace_message('outgoing', { 'id': request_id, 'error': { 'code': getattr(e, 'code', -1), 'message': str(e) } }) raise finally: # 记录性能 duration = time.time() - start_time self.debugger.record_performance(method, duration, { 'request_id': request_id }) async def get_debug_info(self) -\u003e Dict[str, Any]: \"\"\"获取调试信息\"\"\" return self.debugger.get_debug_report() ","date":"2025-06-15","objectID":"/mcp/:4:4","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"智能错误恢复机制 自动故障恢复 import asyncio from typing import Callable, Dict, Any, Optional from enum import Enum class RecoveryStrategy(Enum): \"\"\"恢复策略\"\"\" RETRY = \"retry\" FALLBACK = \"fallback\" CIRCUIT_BREAKER = \"circuit_breaker\" GRACEFUL_DEGRADATION = \"graceful_degradation\" class ErrorRecoveryManager: \"\"\"错误恢复管理器\"\"\" def __init__(self): self.recovery_strategies: Dict[str, RecoveryStrategy] = {} self.fallback_handlers: Dict[str, Callable] = {} self.retry_policies: Dict[str, Dict] = {} self.circuit_breakers: Dict[str, CircuitBreaker] = {} def register_strategy(self, operation: str, strategy: RecoveryStrategy, **kwargs): \"\"\"注册恢复策略\"\"\" self.recovery_strategies[operation] = strategy if strategy == RecoveryStrategy.RETRY: self.retry_policies[operation] = { 'max_attempts': kwargs.get('max_attempts', 3), 'delay': kwargs.get('delay', 1.0), 'backoff_multiplier': kwargs.get('backoff_multiplier', 2.0), 'max_delay': kwargs.get('max_delay', 30.0) } elif strategy == RecoveryStrategy.CIRCUIT_BREAKER: self.circuit_breakers[operation] = CircuitBreaker( failure_threshold=kwargs.get('failure_threshold', 5), timeout=kwargs.get('timeout', 60) ) def register_fallback(self, operation: str, handler: Callable): \"\"\"注册降级处理器\"\"\" self.fallback_handlers[operation] = handler async def execute_with_recovery(self, operation: str, func: Callable, *args, **kwargs): \"\"\"带恢复机制的执行\"\"\" strategy = self.recovery_strategies.get(operation, RecoveryStrategy.RETRY) if strategy == RecoveryStrategy.RETRY: return await self._execute_with_retry(operation, func, *args, **kwargs) elif strategy == RecoveryStrategy.FALLBACK: return await self._execute_with_fallback(operation, func, *args, **kwargs) elif strategy == RecoveryStrategy.CIRCUIT_BREAKER: return await self._execute_with_circuit_breaker(operation, func, *args, **kwargs) elif strategy == RecoveryStrategy.GRACEFUL_DEGRADATION: return await self._execute_with_degradation(operation, func, *args, **kwargs) else: return await func(*args, **kwargs) async def _execute_with_retry(self, operation: str, func: Callable, *args, **kwargs): \"\"\"重试执行\"\"\" policy = self.retry_policies.get(operation, {}) max_attempts = policy.get('max_attempts', 3) delay = policy.get('delay', 1.0) backoff_multiplier = policy.get('backoff_multiplier', 2.0) max_delay = policy.get('max_delay', 30.0) last_exception = None current_delay = delay for attempt in range(max_attempts): try: return await func(*args, **kwargs) except Exception as e: last_exception = e if attempt \u003c max_attempts - 1: await asyncio.sleep(current_delay) current_delay = min(current_delay * backoff_multiplier, max_delay) # 所有重试都失败，抛出最后一个异常 raise last_exception async def _execute_with_fallback(self, operation: str, func: Callable, *args, **kwargs): \"\"\"降级执行\"\"\" try: return await func(*args, **kwargs) except Exception as e: fallback_handler = self.fallback_handlers.get(operation) if fallback_handler: return await fallback_handler(*args, **kwargs) raise e async def _execute_with_circuit_breaker(self, operation: str, func: Callable, *args, **kwargs): \"\"\"熔断器执行\"\"\" circuit_breaker = self.circuit_breakers.get(operation) if not circuit_breaker: return await func(*args, **kwargs) if circuit_breaker.is_open(): raise McpError( code=ErrorCode.SERVICE_UNAVAILABLE, message=f\"服务 {operation} 熔断中\" ) try: result = await func(*args, **kwargs) circuit_breaker.record_success() return result except Exception as e: circuit_breaker.record_failure() raise e async def _execute_with_degradation(self, operation: str, func: Callable, *args, **kwargs): \"\"\"优雅降级执行\"\"\" try: return await func(*args, **kwargs) except Exception as e: # 记录错误但返回降级结果 fallback_handler = self.fallback_handlers.get(operation) if fallback_handler: try: return await fallback_handler(*args, **kwargs) except Exception: # 降级也失败，返回默认值 return self._get_default_response(operation) return self._get_default_response(operation) def _get_default_response(self, operation: str): \"\"\"获取默认响应\"\"\" if operation.startswith('read_'): return \"\" elif operation.startswith('list_'): return [] elif o","date":"2025-06-15","objectID":"/mcp/:4:5","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"多租户支持 租户隔离机制 from typing import Dict, Set, Optional import hashlib class TenantManager: \"\"\"租户管理器\"\"\" def __init__(self): self.tenants: Dict[str, Dict] = {} self.tenant_resources: Dict[str, Set[str]] = {} self.tenant_quotas: Dict[str, Dict] = {} self.tenant_usage: Dict[str, Dict] = {} def create_tenant(self, tenant_id: str, config: Dict): \"\"\"创建租户\"\"\" self.tenants[tenant_id] = { 'id': tenant_id, 'name': config.get('name', tenant_id), 'created_at': time.time(), 'status': 'active', 'config': config } # 初始化资源和配额 self.tenant_resources[tenant_id] = set() self.tenant_quotas[tenant_id] = { 'max_resources': config.get('max_resources', 100), 'max_requests_per_minute': config.get('max_requests_per_minute', 1000), 'max_storage_mb': config.get('max_storage_mb', 1024) } self.tenant_usage[tenant_id] = { 'resources_count': 0, 'requests_count': 0, 'storage_used_mb': 0, 'last_reset': time.time() } def get_tenant(self, tenant_id: str) -\u003e Optional[Dict]: \"\"\"获取租户信息\"\"\" return self.tenants.get(tenant_id) def check_quota(self, tenant_id: str, resource_type: str, amount: int = 1) -\u003e bool: \"\"\"检查配额\"\"\" if tenant_id not in self.tenant_quotas: return False quota = self.tenant_quotas[tenant_id] usage = self.tenant_usage[tenant_id] # 重置每分钟的请求计数 current_time = time.time() if current_time - usage['last_reset'] \u003e= 60: usage['requests_count'] = 0 usage['last_reset'] = current_time if resource_type == 'requests': return usage['requests_count'] + amount \u003c= quota['max_requests_per_minute'] elif resource_type == 'resources': return usage['resources_count'] + amount \u003c= quota['max_resources'] elif resource_type == 'storage': return usage['storage_used_mb'] + amount \u003c= quota['max_storage_mb'] return True def consume_quota(self, tenant_id: str, resource_type: str, amount: int = 1): \"\"\"消费配额\"\"\" if tenant_id not in self.tenant_usage: return usage = self.tenant_usage[tenant_id] if resource_type == 'requests': usage['requests_count'] += amount elif resource_type == 'resources': usage['resources_count'] += amount elif resource_type == 'storage': usage['storage_used_mb'] += amount def get_tenant_namespace(self, tenant_id: str, resource_name: str) -\u003e str: \"\"\"获取租户命名空间的资源名\"\"\" return f\"tenant:{tenant_id}:{resource_name}\" class MultiTenantMcpServer(McpServer): \"\"\"多租户MCP服务器\"\"\" def __init__(self, name: str): super().__init__(name) self.tenant_manager = TenantManager() self.tenant_contexts: Dict[str, str] = {} # 连接ID -\u003e 租户ID映射 async def authenticate_tenant(self, token: str) -\u003e Optional[str]: \"\"\"租户认证\"\"\" # 这里应该实现实际的JWT验证逻辑 # 为简化示例，直接从token中提取租户ID try: # 假设token格式为 \"tenant_id:signature\" tenant_id = token.split(':')[0] if self.tenant_manager.get_tenant(tenant_id): return tenant_id except Exception: pass return None async def handle_request(self, method: str, params: dict): \"\"\"处理多租户请求\"\"\" # 获取当前连接的租户ID connection_id = self.get_current_connection_id() tenant_id = self.tenant_contexts.get(connection_id) if not tenant_id: raise McpError( code=ErrorCode.UNAUTHORIZED, message=\"需要租户认证\" ) # 检查请求配额 if not self.tenant_manager.check_quota(tenant_id, 'requests'): raise McpError( code=ErrorCode.RATE_LIMITED, message=\"租户请求配额已用完\" ) # 消费配额 self.tenant_manager.consume_quota(tenant_id, 'requests') # 在请求参数中注入租户上下文 params['_tenant_id'] = tenant_id return await super().handle_request(method, params) async def read_resource(self, uri: str) -\u003e str: \"\"\"多租户资源读取\"\"\" tenant_id = self._get_current_tenant_id() # 添加租户命名空间 namespaced_uri = self.tenant_manager.get_tenant_namespace(tenant_id, uri) return await super().read_resource(namespaced_uri) async def list_resources(self) -\u003e List[Resource]: \"\"\"列出租户资源\"\"\" tenant_id = self._get_current_tenant_id() # 获取所有资源并过滤租户资源 all_resources = await super().list_resources() tenant_prefix = f\"tenant:{tenant_id}:\" tenant_resources = [] for resource in all_resources: if resource.uri.startswith(tenant_prefix): # 移除租户前缀，返回原始URI original_uri = resource.uri[len(tenant_prefix):] tenant_resources.append(Resource( uri=original_uri, name=resource.name, description=resource.description, mimeType=res","date":"2025-06-15","objectID":"/mcp/:4:6","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🛠️ MCP开发实践 ","date":"2025-06-15","objectID":"/mcp/:5:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"开发环境搭建 1. 安装开发工具 # Python环境 pip install mcp # TypeScript环境 npm install @modelcontextprotocol/sdk # 调试工具 npm install -g @modelcontextprotocol/inspector 2. 项目结构 my-mcp-server/ ├── src/ │ ├── __init__.py │ ├── server.py # 主服务器代码 │ ├── resources.py # 资源处理 │ ├── tools.py # 工具实现 │ └── prompts.py # 提示模板 ├── config/ │ └── server_config.json ├── tests/ │ └── test_server.py ├── requirements.txt └── README.md ","date":"2025-06-15","objectID":"/mcp/:5:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"开发最佳实践 1. 服务器设计原则 from mcp import McpServer from typing import List, Optional import asyncio class BestPracticeServer(McpServer): def __init__(self): super().__init__(\"best-practice-server\") self.name = \"最佳实践服务器\" self.version = \"1.0.0\" async def initialize(self): \"\"\"初始化服务器资源\"\"\" self.logger.info(\"服务器初始化中...\") # 初始化数据库连接、缓存等 async def cleanup(self): \"\"\"清理资源\"\"\" self.logger.info(\"服务器清理中...\") # 关闭连接、清理缓存等 2. 错误处理 from mcp import McpError, ErrorCode async def safe_tool_call(self, name: str, arguments: dict): try: # 工具执行逻辑 result = await self.execute_tool(name, arguments) return result except ValidationError as e: raise McpError( code=ErrorCode.INVALID_PARAMS, message=f\"参数验证失败: {str(e)}\" ) except PermissionError as e: raise McpError( code=ErrorCode.PERMISSION_DENIED, message=\"权限不足\" ) except Exception as e: self.logger.error(f\"工具执行失败: {str(e)}\") raise McpError( code=ErrorCode.INTERNAL_ERROR, message=\"内部服务器错误\" ) 3. 性能优化 import asyncio from functools import lru_cache class OptimizedServer(McpServer): @lru_cache(maxsize=100) async def get_cached_resource(self, uri: str): \"\"\"缓存资源内容\"\"\" return await self.load_resource(uri) async def batch_process_resources(self, uris: List[str]): \"\"\"批量处理资源\"\"\" tasks = [self.get_cached_resource(uri) for uri in uris] return await asyncio.gather(*tasks) ","date":"2025-06-15","objectID":"/mcp/:5:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"调试与测试 1. 使用MCP Inspector # 启动调试工具 npx @modelcontextprotocol/inspector # 测试服务器连接 mcp-inspector --server python my_server.py 2. 单元测试 import pytest from mcp.testing import McpTestClient @pytest.mark.asyncio async def test_resource_listing(): client = McpTestClient(MyMcpServer()) await client.connect() resources = await client.list_resources() assert len(resources) \u003e 0 assert resources[0].name == \"测试资源\" ","date":"2025-06-15","objectID":"/mcp/:5:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🔧 实际应用案例 ","date":"2025-06-15","objectID":"/mcp/:6:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"案例一：代码库分析服务器 需求分析 为AI模型提供代码库的完整上下文，包括文件结构、代码内容、Git历史等。 实现方案 class CodebaseServer(McpServer): def __init__(self, repo_path: str): super().__init__(\"codebase-server\") self.repo_path = repo_path self.git_repo = GitRepository(repo_path) async def list_resources(self): \"\"\"列出代码库中的所有文件\"\"\" files = [] for root, dirs, filenames in os.walk(self.repo_path): for filename in filenames: if self.is_code_file(filename): file_path = os.path.join(root, filename) relative_path = os.path.relpath(file_path, self.repo_path) files.append(Resource( uri=f\"file://{file_path}\", name=relative_path, description=f\"代码文件: {relative_path}\", mimeType=self.get_mime_type(filename) )) return files async def list_tools(self): return [ Tool( name=\"analyze_code_structure\", description=\"分析代码结构和依赖关系\", inputSchema={ \"type\": \"object\", \"properties\": { \"file_pattern\": { \"type\": \"string\", \"description\": \"文件匹配模式\" } } } ), Tool( name=\"get_git_history\", description=\"获取Git提交历史\", inputSchema={ \"type\": \"object\", \"properties\": { \"file_path\": { \"type\": \"string\", \"description\": \"文件路径\" }, \"limit\": { \"type\": \"integer\", \"description\": \"历史记录数量限制\" } } } ) ] ","date":"2025-06-15","objectID":"/mcp/:6:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"案例二：数据库管理服务器 功能特性 数据库连接管理 SQL查询执行 表结构分析 数据安全保护 实现代码 import asyncpg from typing import Dict, Any class DatabaseServer(McpServer): def __init__(self, db_config: Dict[str, Any]): super().__init__(\"database-server\") self.db_config = db_config self.connection_pool = None async def initialize(self): \"\"\"初始化数据库连接池\"\"\" self.connection_pool = await asyncpg.create_pool( **self.db_config, min_size=1, max_size=10 ) async def list_resources(self): \"\"\"列出数据库表和视图\"\"\" async with self.connection_pool.acquire() as conn: tables = await conn.fetch(\"\"\" SELECT table_name, table_type FROM information_schema.tables WHERE table_schema = 'public' \"\"\") return [ Resource( uri=f\"table://{table['table_name']}\", name=table['table_name'], description=f\"数据库{table['table_type']}: {table['table_name']}\", mimeType=\"application/sql\" ) for table in tables ] async def call_tool(self, name: str, arguments: dict): if name == \"execute_query\": query = arguments[\"query\"] # 安全检查 if not self.is_safe_query(query): raise McpError( code=ErrorCode.PERMISSION_DENIED, message=\"查询包含不安全的操作\" ) async with self.connection_pool.acquire() as conn: try: result = await conn.fetch(query) return ToolResult( content=[{ \"type\": \"text\", \"text\": self.format_query_result(result) }] ) except Exception as e: return ToolResult( content=[{ \"type\": \"text\", \"text\": f\"查询执行失败: {str(e)}\" }], isError=True ) def is_safe_query(self, query: str) -\u003e bool: \"\"\"检查查询是否安全\"\"\" dangerous_keywords = [ 'DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE' ] query_upper = query.upper() return not any(keyword in query_upper for keyword in dangerous_keywords) ","date":"2025-06-15","objectID":"/mcp/:6:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"案例三：文档知识库服务器 应用场景 为AI助手提供企业内部文档、知识库的访问能力。 核心实现 from pathlib import Path import markdown from bs4 import BeautifulSoup class KnowledgeBaseServer(McpServer): def __init__(self, docs_path: str): super().__init__(\"knowledge-base-server\") self.docs_path = Path(docs_path) self.doc_index = {} async def initialize(self): \"\"\"构建文档索引\"\"\" await self.build_document_index() async def build_document_index(self): \"\"\"构建文档索引以支持快速搜索\"\"\" for doc_file in self.docs_path.rglob(\"*.md\"): content = doc_file.read_text(encoding='utf-8') # 提取标题和关键词 html = markdown.markdown(content) soup = BeautifulSoup(html, 'html.parser') self.doc_index[str(doc_file)] = { 'title': self.extract_title(soup), 'keywords': self.extract_keywords(content), 'summary': self.generate_summary(content) } async def list_prompts(self): return [ Prompt( name=\"document_qa\", description=\"文档问答提示模板\", arguments=[ PromptArgument( name=\"question\", description=\"用户问题\", required=True ), PromptArgument( name=\"context_docs\", description=\"相关文档\", required=False ) ] ) ] async def get_prompt(self, name: str, arguments: dict): if name == \"document_qa\": question = arguments[\"question\"] context_docs = arguments.get(\"context_docs\", \"\") return f\"\"\" 基于以下文档内容回答用户问题。 相关文档： {context_docs} 用户问题：{question} 请基于文档内容提供准确、详细的回答。如果文档中没有相关信息，请明确说明。 \"\"\" ","date":"2025-06-15","objectID":"/mcp/:6:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🏢 企业级部署方案 ","date":"2025-06-15","objectID":"/mcp/:7:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"部署架构 1. 本地部署 # docker-compose.yml version: '3.8' services: mcp-server: build: . ports: - \"8080:8080\" environment: - DB_HOST=postgres - REDIS_URL=redis://redis:6379 volumes: - ./data:/app/data depends_on: - postgres - redis postgres: image: postgres:15 environment: POSTGRES_DB: mcpdata POSTGRES_USER: mcpuser POSTGRES_PASSWORD: mcppass volumes: - postgres_data:/var/lib/postgresql/data redis: image: redis:7-alpine volumes: postgres_data: 2. 云端部署 # Kubernetes部署示例 kubectl apply -f - \u003c\u003cEOF apiVersion: apps/v1 kind: Deployment metadata: name: mcp-server spec: replicas: 3 selector: matchLabels: app: mcp-server template: metadata: labels: app: mcp-server spec: containers: - name: mcp-server image: my-org/mcp-server:latest ports: - containerPort: 8080 env: - name: DB_HOST value: \"postgres-service\" - name: REDIS_URL value: \"redis://redis-service:6379\" EOF ","date":"2025-06-15","objectID":"/mcp/:7:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"安全最佳实践 1. 认证授权 from functools import wraps import jwt class SecureMcpServer(McpServer): def __init__(self): super().__init__(\"secure-server\") self.jwt_secret = os.getenv(\"JWT_SECRET\") self.authorized_clients = set() def require_auth(self, func): @wraps(func) async def wrapper(*args, **kwargs): client_id = self.get_current_client_id() if client_id not in self.authorized_clients: raise McpError( code=ErrorCode.PERMISSION_DENIED, message=\"未授权的客户端\" ) return await func(*args, **kwargs) return wrapper @require_auth async def call_tool(self, name: str, arguments: dict): # 安全的工具调用 return await super().call_tool(name, arguments) 2. 数据加密 from cryptography.fernet import Fernet class EncryptedDataServer(McpServer): def __init__(self): super().__init__(\"encrypted-server\") self.cipher_suite = Fernet(os.getenv(\"ENCRYPTION_KEY\")) async def read_resource(self, uri: str): \"\"\"读取加密资源\"\"\" encrypted_data = await self.load_encrypted_data(uri) decrypted_data = self.cipher_suite.decrypt(encrypted_data) return decrypted_data.decode('utf-8') ","date":"2025-06-15","objectID":"/mcp/:7:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🚀 未来发展趋势 ","date":"2025-06-15","objectID":"/mcp/:8:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"技术演进方向 1. 协议增强 🔮 未来特性： - 流式数据传输支持 - 更强的类型系统 - 内置缓存机制 - 事务支持 - 更好的错误恢复 2. 生态系统扩展 🌍 生态发展： - 更多预构建服务器 - 可视化配置工具 - 监控和分析平台 - 插件市场 - 企业级管理控制台 3. 与AI Agent集成 # 未来的AI Agent集成示例 class IntelligentMcpAgent: def __init__(self): self.mcp_clients = [] self.reasoning_engine = ReasoningEngine() async def process_request(self, user_request: str): # 1. 分析用户请求 intent = await self.reasoning_engine.analyze_intent(user_request) # 2. 选择合适的MCP服务器 relevant_servers = self.select_servers(intent) # 3. 收集上下文信息 context = await self.gather_context(relevant_servers, intent) # 4. 生成响应 response = await self.generate_response(context, user_request) return response ","date":"2025-06-15","objectID":"/mcp/:8:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"📊 性能优化与监控系统 ","date":"2025-06-15","objectID":"/mcp/:9:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"高级性能监控 实时性能指标收集 import psutil import asyncio from dataclasses import dataclass, asdict from typing import Dict, List import time from collections import deque @dataclass class PerformanceMetrics: \"\"\"性能指标数据结构\"\"\" timestamp: float cpu_usage: float memory_usage: float memory_available: int disk_io_read: int disk_io_write: int network_sent: int network_recv: int active_connections: int response_time: float request_count: int error_count: int class PerformanceMonitor: \"\"\"性能监控器\"\"\" def __init__(self, collection_interval: int = 5): self.collection_interval = collection_interval self.metrics_history: deque = deque(maxlen=1000) # 保留最近1000条记录 self.is_monitoring = False self.thresholds = { 'cpu_usage': 80.0, 'memory_usage': 85.0, 'response_time': 5.0, 'error_rate': 0.05 } self.alerts = [] async def start_monitoring(self): \"\"\"启动监控\"\"\" self.is_monitoring = True while self.is_monitoring: metrics = await self.collect_metrics() self.metrics_history.append(metrics) # 检查告警阈值 await self.check_alerts(metrics) await asyncio.sleep(self.collection_interval) async def collect_metrics(self) -\u003e PerformanceMetrics: \"\"\"收集性能指标\"\"\" # 系统资源指标 cpu_usage = psutil.cpu_percent(interval=1) memory = psutil.virtual_memory() disk_io = psutil.disk_io_counters() network_io = psutil.net_io_counters() # 应用指标 active_connections = await self.get_active_connections() response_time = await self.get_average_response_time() request_count = await self.get_request_count() error_count = await self.get_error_count() return PerformanceMetrics( timestamp=time.time(), cpu_usage=cpu_usage, memory_usage=memory.percent, memory_available=memory.available, disk_io_read=disk_io.read_bytes if disk_io else 0, disk_io_write=disk_io.write_bytes if disk_io else 0, network_sent=network_io.bytes_sent if network_io else 0, network_recv=network_io.bytes_recv if network_io else 0, active_connections=active_connections, response_time=response_time, request_count=request_count, error_count=error_count ) async def check_alerts(self, metrics: PerformanceMetrics): \"\"\"检查告警条件\"\"\" alerts = [] if metrics.cpu_usage \u003e self.thresholds['cpu_usage']: alerts.append({ 'type': 'CPU_HIGH', 'message': f'CPU使用率过高: {metrics.cpu_usage:.2f}%', 'severity': 'WARNING', 'timestamp': metrics.timestamp }) if metrics.memory_usage \u003e self.thresholds['memory_usage']: alerts.append({ 'type': 'MEMORY_HIGH', 'message': f'内存使用率过高: {metrics.memory_usage:.2f}%', 'severity': 'WARNING', 'timestamp': metrics.timestamp }) if metrics.response_time \u003e self.thresholds['response_time']: alerts.append({ 'type': 'RESPONSE_SLOW', 'message': f'响应时间过长: {metrics.response_time:.2f}s', 'severity': 'CRITICAL', 'timestamp': metrics.timestamp }) # 计算错误率 if metrics.request_count \u003e 0: error_rate = metrics.error_count / metrics.request_count if error_rate \u003e self.thresholds['error_rate']: alerts.append({ 'type': 'ERROR_RATE_HIGH', 'message': f'错误率过高: {error_rate:.2%}', 'severity': 'CRITICAL', 'timestamp': metrics.timestamp }) self.alerts.extend(alerts) # 发送告警通知 for alert in alerts: await self.send_alert_notification(alert) def get_metrics_summary(self, duration_minutes: int = 60) -\u003e Dict: \"\"\"获取指标摘要\"\"\" cutoff_time = time.time() - (duration_minutes * 60) recent_metrics = [m for m in self.metrics_history if m.timestamp \u003e= cutoff_time] if not recent_metrics: return {} return { 'avg_cpu_usage': sum(m.cpu_usage for m in recent_metrics) / len(recent_metrics), 'avg_memory_usage': sum(m.memory_usage for m in recent_metrics) / len(recent_metrics), 'avg_response_time': sum(m.response_time for m in recent_metrics) / len(recent_metrics), 'total_requests': sum(m.request_count for m in recent_metrics), 'total_errors': sum(m.error_count for m in recent_metrics), 'error_rate': sum(m.error_count for m in recent_metrics) / max(sum(m.request_count for m in recent_metrics), 1), 'sample_count': len(recent_metrics) } class MonitoredMcpServer(McpServer): \"\"\"带性能监控的MCP服务器\"\"\" def __init__(self): super().__init__(\"monitored-server\") self.performance_monitor = PerformanceMonitor() self.request","date":"2025-06-15","objectID":"/mcp/:9:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"缓存优化策略 多级缓存系统 import redis import pickle from typing import Any, Optional, Union from abc import ABC, abstractmethod class CacheBackend(ABC): \"\"\"缓存后端抽象基类\"\"\" @abstractmethod async def get(self, key: str) -\u003e Optional[Any]: pass @abstractmethod async def set(self, key: str, value: Any, ttl: int = None): pass @abstractmethod async def delete(self, key: str): pass @abstractmethod async def exists(self, key: str) -\u003e bool: pass class MemoryCache(CacheBackend): \"\"\"内存缓存\"\"\" def __init__(self, max_size: int = 1000): self.cache = {} self.max_size = max_size self.access_times = {} async def get(self, key: str) -\u003e Optional[Any]: if key in self.cache: self.access_times[key] = time.time() return self.cache[key] return None async def set(self, key: str, value: Any, ttl: int = None): if len(self.cache) \u003e= self.max_size: # LRU淘汰 oldest_key = min(self.access_times.keys(), key=lambda k: self.access_times[k]) await self.delete(oldest_key) self.cache[key] = value self.access_times[key] = time.time() if ttl: # 设置过期时间 asyncio.create_task(self._expire_key(key, ttl)) async def _expire_key(self, key: str, ttl: int): await asyncio.sleep(ttl) await self.delete(key) async def delete(self, key: str): self.cache.pop(key, None) self.access_times.pop(key, None) async def exists(self, key: str) -\u003e bool: return key in self.cache class RedisCache(CacheBackend): \"\"\"Redis缓存\"\"\" def __init__(self, redis_url: str = \"redis://localhost:6379\"): self.redis = redis.from_url(redis_url, decode_responses=False) async def get(self, key: str) -\u003e Optional[Any]: data = await self.redis.get(key) if data: return pickle.loads(data) return None async def set(self, key: str, value: Any, ttl: int = None): data = pickle.dumps(value) if ttl: await self.redis.setex(key, ttl, data) else: await self.redis.set(key, data) async def delete(self, key: str): await self.redis.delete(key) async def exists(self, key: str) -\u003e bool: return await self.redis.exists(key) class MultiLevelCache: \"\"\"多级缓存系统\"\"\" def __init__(self): self.levels = [ MemoryCache(max_size=100), # L1: 内存缓存 RedisCache(), # L2: Redis缓存 ] async def get(self, key: str) -\u003e Optional[Any]: \"\"\"从缓存获取数据，按级别查找\"\"\" for i, cache in enumerate(self.levels): value = await cache.get(key) if value is not None: # 回填到更高级别的缓存 for j in range(i): await self.levels[j].set(key, value) return value return None async def set(self, key: str, value: Any, ttl: int = None): \"\"\"设置缓存到所有级别\"\"\" for cache in self.levels: await cache.set(key, value, ttl) async def delete(self, key: str): \"\"\"从所有级别删除缓存\"\"\" for cache in self.levels: await cache.delete(key) class CachedMcpServer(McpServer): \"\"\"带缓存的MCP服务器\"\"\" def __init__(self): super().__init__(\"cached-server\") self.cache = MultiLevelCache() self.cache_stats = { 'hits': 0, 'misses': 0, 'sets': 0, 'deletes': 0 } async def read_resource(self, uri: str) -\u003e str: \"\"\"带缓存的资源读取\"\"\" cache_key = f\"resource:{uri}\" # 尝试从缓存获取 cached_data = await self.cache.get(cache_key) if cached_data is not None: self.cache_stats['hits'] += 1 return cached_data # 缓存未命中，从源读取 self.cache_stats['misses'] += 1 data = await super().read_resource(uri) # 存入缓存 await self.cache.set(cache_key, data, ttl=3600) # 1小时过期 self.cache_stats['sets'] += 1 return data def get_cache_stats(self) -\u003e Dict: \"\"\"获取缓存统计\"\"\" total_requests = self.cache_stats['hits'] + self.cache_stats['misses'] hit_rate = self.cache_stats['hits'] / max(total_requests, 1) return { 'hit_rate': hit_rate, 'total_hits': self.cache_stats['hits'], 'total_misses': self.cache_stats['misses'], 'total_sets': self.cache_stats['sets'], 'total_deletes': self.cache_stats['deletes'] } ","date":"2025-06-15","objectID":"/mcp/:9:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"性能调优 1. 连接池管理 import asyncio from contextlib import asynccontextmanager class PooledMcpServer(McpServer): def __init__(self): super().__init__(\"pooled-server\") self.connection_pool = asyncio.Queue(maxsize=10) self.metrics = { 'active_connections': 0, 'total_requests': 0, 'error_count': 0 } @asynccontextmanager async def get_connection(self): \"\"\"获取连接的上下文管理器\"\"\" try: self.metrics['active_connections'] += 1 connection = await self.connection_pool.get() yield connection finally: await self.connection_pool.put(connection) self.metrics['active_connections'] -= 1 2. 请求限流 import time from collections import defaultdict class RateLimitedServer(McpServer): def __init__(self): super().__init__(\"rate-limited-server\") self.request_counts = defaultdict(list) self.rate_limit = 100 # 每分钟100个请求 async def check_rate_limit(self, client_id: str): \"\"\"检查请求频率限制\"\"\" now = time.time() minute_ago = now - 60 # 清理过期记录 self.request_counts[client_id] = [ timestamp for timestamp in self.request_counts[client_id] if timestamp \u003e minute_ago ] # 检查是否超过限制 if len(self.request_counts[client_id]) \u003e= self.rate_limit: raise McpError( code=ErrorCode.RATE_LIMITED, message=\"请求频率过高，请稍后重试\" ) self.request_counts[client_id].append(now) ","date":"2025-06-15","objectID":"/mcp/:9:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"监控体系 1. 指标收集 import time from dataclasses import dataclass from typing import Dict, Any @dataclass class RequestMetrics: method: str duration: float success: bool client_id: str timestamp: float class MonitoredMcpServer(McpServer): def __init__(self): super().__init__(\"monitored-server\") self.metrics: List[RequestMetrics] = [] self.health_status = \"healthy\" async def handle_request(self, method: str, params: Dict[str, Any]): \"\"\"处理请求并收集指标\"\"\" start_time = time.time() client_id = self.get_current_client_id() success = True try: result = await super().handle_request(method, params) return result except Exception as e: success = False raise finally: duration = time.time() - start_time self.metrics.append(RequestMetrics( method=method, duration=duration, success=success, client_id=client_id, timestamp=start_time )) async def get_health_status(self): \"\"\"健康检查端点\"\"\" recent_errors = [ m for m in self.metrics[-100:] # 最近100个请求 if not m.success ] error_rate = len(recent_errors) / min(100, len(self.metrics)) if error_rate \u003e 0.1: # 错误率超过10% self.health_status = \"unhealthy\" else: self.health_status = \"healthy\" return { \"status\": self.health_status, \"error_rate\": error_rate, \"total_requests\": len(self.metrics), \"uptime\": time.time() - self.start_time } ","date":"2025-06-15","objectID":"/mcp/:9:4","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"📚 学习资源与社区 ","date":"2025-06-15","objectID":"/mcp/:10:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"官方资源 MCP官方文档 - 完整的协议规范和开发指南 Anthropic官方博客 - MCP发布公告和技术解读 GitHub仓库 - 官方SDK和示例代码 MCP Inspector - 调试和测试工具 ","date":"2025-06-15","objectID":"/mcp/:10:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"开发工具 Python SDK: pip install mcp TypeScript SDK: npm install @modelcontextprotocol/sdk 调试工具: npm install -g @modelcontextprotocol/inspector ","date":"2025-06-15","objectID":"/mcp/:10:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"社区项目 🔧 实用工具： - MCP服务器模板库 - 可视化配置工具 - 性能监控仪表板 - 自动化测试框架 🌟 开源服务器： - 文件系统服务器 - 数据库连接器 - GitHub集成 - Slack集成 - Google Drive连接器 ","date":"2025-06-15","objectID":"/mcp/:10:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"📝 总结 MCP（Model Context Protocol）作为AI领域的重要技术创新，为构建智能、互联的AI系统提供了标准化的解决方案。通过本文的深入解析，我们了解了： ","date":"2025-06-15","objectID":"/mcp/:11:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🎯 核心价值 标准化: 统一AI模型与数据源的连接方式 可扩展: 支持灵活的服务器组合和扩展 安全性: 内置权限控制和数据保护机制 开放性: 开源协议，促进生态发展 ","date":"2025-06-15","objectID":"/mcp/:11:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🏗️ 技术特点 简洁的客户端-服务器架构 强大的Resources、Tools、Prompts三大核心概念 灵活的传输协议支持 完善的错误处理机制 ","date":"2025-06-15","objectID":"/mcp/:11:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🚀 发展前景 MCP将成为AI应用开发的重要基础设施，推动AI工具的标准化和生态化发展。随着更多工具和平台的支持，MCP生态系统将越来越丰富，为开发者和企业提供更强大的AI应用构建能力。 开始你的MCP之旅：从简单的文件系统服务器开始，逐步探索更复杂的应用场景，加入这个激动人心的技术生态！ 参考资料： Anthropic官方MCP介绍 MCP官方文档 MCP GitHub仓库 💡 提示：MCP技术还在快速发展中，建议关注官方更新，及时学习新特性和最佳实践！ ","date":"2025-06-15","objectID":"/mcp/:11:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI资讯","AI"],"content":"了解最新AI前沿资讯信息，关注最新AI发展动向","date":"2025-07-08","objectID":"/ai_01/","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI资讯了解渠道","uri":"/ai_01/"},{"categories":["AI资讯","AI"],"content":"AI资讯渠道 量子位 新智元 AI 日刊 AI今日热榜 — AI资讯聚合网站 linux.do 人工智能模块 Reddit ClaudeAI bensbites 三花快讯 MIT Technology Review – The Algorithm The Verge – AI WIRED – AI ","date":"2025-07-08","objectID":"/ai_01/:0:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI资讯了解渠道","uri":"/ai_01/"},{"categories":["English","English Study"],"content":"学习英语获取第一手信息","date":"2025-07-17","objectID":"/english_01/","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"学习目标 学习英语的主要目的是为了获取第一手信息，特别是在计算机技术、互联网、AI领域和学术研究方面。通过提升英语能力，能够： 阅读最新的技术文档和研究论文 观看英文技术视频和教程 参与国际技术社区讨论 获取最前沿的行业资讯 ","date":"2025-07-17","objectID":"/english_01/:1:0","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"核心学习资源 ","date":"2025-07-17","objectID":"/english_01/:2:0","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"Lexile 蓝思 Lexile 蓝思(蓝思值在衡量一本书的词汇难度，越高越难) Lexile: 蓝思 蓝思值图书查询 The Little Prince:小王子 蓝思值为：710 Animal Farm:动物庄园 蓝思值为：940 Harry Potter:哈利波特原本7步 蓝思值为：500～950 Educated:你当像鸟飞往你的山 蓝思值为：870 Elon Musk:硅谷钢铁侠 蓝思值为：1200 ","date":"2025-07-17","objectID":"/english_01/:2:1","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"学习资源 BBC Learning English - BBC官方英语学习平台，内容权威且系统 英语自学指南 - 系统的英语自学方法论 英语进阶指南 - 详细的英语学习进阶路径 人人都能用英语 - 李笑来的英语学习理念 Learning English —— 精选优质英语学习资源合集，专注于听说读写等核心技能的提升。包含语法、词汇和媒体资源，助您更好地学习英语。 OGDEN’s BASIC ENGLISH —— 作者发现牛津字典中2.5w单词中90%的概念可以用850个单词来实现，使用简单的英语进行交流 YouTube BBC Learning English - English In A Minute English-level-up-tips：英语进阶指南 —— 全面的英语学习指南 Everyone Can Use English：人人都能用英语-李笑来 英语自学 English Note —— 帮助初学者从零开始系统学习英语语法 Chinese Programmer Wrong Pronunciation：中国程序员容易发音错误的单词 —— 帮助中国程序员纠正常见的英语发音错误，特别是与技术术语和编程语言相关的词汇 专为程序员编写的英语学习指南 学习英语的新闻网站 ","date":"2025-07-17","objectID":"/english_01/:2:2","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"Youtube英语学习Channel： English with Lucy (British) mmmEnglish (Australian) Learn English with Emma(engVid) (Canadian) BBC Learning English (British, of course) Oxford Online English Learn English with TV series (American) Accent’s Way English with Hadar (American) Learn English with Papa Teach Me (British) English Like A Native (British) Go natural English (American) Instant English English with Jennifer LearnAmericanEnglishOnline EnglishSpeakingSuccess Learn English with EnglishClass101.com E2 IELTS English Addict with Mr Duncan Rachel’s English Kendra’s Language School Speak English With Vanessa EnglishAnyone 阿滴英文 IELTS buddy 跟洋妞学英语 Jackie ","date":"2025-07-17","objectID":"/english_01/:2:3","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"播客学习计划 ","date":"2025-07-17","objectID":"/english_01/:3:0","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"初学者友好播客 这些播客语速较慢，内容简单易懂，适合英语学习初期： 6 Minute English BBC制作的简短英语学习节目 每集仅6分钟，针对初中级学习者 内容通俗易懂，主题丰富 The English We Speak BBC出品，专注于日常英语短语和俚语学习 每集3-4分钟，非常适合初学者 学习地道的英语表达 ESLPod 专为英语学习者设计的播客 语速缓慢且解释详细 对初学者非常友好 Elementary Podcasts 英国文化协会出品 专为初学者设计的对话和故事 配有完整文字稿 ","date":"2025-07-17","objectID":"/english_01/:3:1","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"进阶学习播客 适合有一定基础后提升听力和学习地道表达： Luke’s ENGLISH Podcast 由英语老师Luke主持 通过轻松有趣的方式教授英语表达和文化 适合中高级学习者 This American Life 美国国宝级广播节目 每期围绕一个主题讲述多个真实故事 语速适中，表达地道 TED Talks Daily 每日更新TED演讲 涵盖广泛话题 多数演讲语速适中 ","date":"2025-07-17","objectID":"/english_01/:3:2","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"技术相关播客 作为程序员，这些播客特别有价值： Lex Fridman Podcast MIT研究员主持的深度访谈节目 邀请科技、科学、艺术等领域的顶尖人物对话 内容深度高，适合技术人员 JS Party: JavaScript, CSS, Web Development 专注于JavaScript和Web开发 讨论最新的前端技术趋势 The Changelog: Software Development, Open Source 软件开发和开源项目讨论 了解开源社区动态 ","date":"2025-07-17","objectID":"/english_01/:3:3","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"实用学习工具 ","date":"2025-07-17","objectID":"/english_01/:4:0","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"浏览器插件 Language Reactor 可以加载双语字幕的插件 支持YouTube和Netflix 提供词汇学习功能 Relingo 自动标示和翻译生词和难词 支持多种网站 个性化词汇学习 Trancy 支持YouTube、NetFlix双语字幕 字幕阅读模式 划词翻译功能 ","date":"2025-07-17","objectID":"/english_01/:4:1","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"阅读工具 Medium Parser Chrome 插件 绕过Medium的付费墙 查看付费文章 获取更多英文技术文章 Bypass Paywalls Clean 支持500+网站的付费墙绕过 包括纽约时报、华尔街日报等主流媒体 获取第一手英文资讯 ","date":"2025-07-17","objectID":"/english_01/:4:2","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"学习策略 ","date":"2025-07-17","objectID":"/english_01/:5:0","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"听力训练 循序渐进：从初学者播客开始，逐步过渡到正常语速内容 重复收听：同一内容多次收听，加深理解 主动记录：记录生词和有用表达 ","date":"2025-07-17","objectID":"/english_01/:5:1","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"阅读提升 技术文档优先：从工作相关的英文文档开始 新闻阅读：每日阅读英文科技新闻 学术论文：逐步尝试阅读相关领域的英文论文 ","date":"2025-07-17","objectID":"/english_01/:5:2","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"实践应用 技术社区参与：在GitHub、Stack Overflow等平台用英文交流 写作练习：尝试用英文写技术博客或文档 口语练习：参加英语技术分享或在线讨论 分享Discord一个英语练习小组，在这里可以和全世界各个地方的语言学习者聊天，有三四人以上的房间，也可以两个人进行一对一聊，练习口语很不错 Call Annie 目前支持iOS美区Apple ID下载和web网页版 duolingo Cambly-和母语外教在线练习口语 ","date":"2025-07-17","objectID":"/english_01/:5:3","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"学习计划 ","date":"2025-07-17","objectID":"/english_01/:6:0","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"每日安排 晨间：收听15-20分钟英语播客 工作间隙：阅读英文技术文章 晚间：观看英文技术视频或TED演讲 ","date":"2025-07-17","objectID":"/english_01/:6:1","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"周度目标 完成3-5期英语播客 阅读2-3篇英文技术文章 学习并记录20-30个新词汇 ","date":"2025-07-17","objectID":"/english_01/:6:2","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["English","English Study"],"content":"月度评估 回顾学习进度 调整学习资源和方法 设定下月学习目标 通过系统的学习和持续的实践，相信能够有效提升英语水平，更好地获取第一手信息，在技术道路上走得更远。 ","date":"2025-07-17","objectID":"/english_01/:6:3","tags":["English Study","English","英语学习"],"title":"我的英语学习","uri":"/english_01/"},{"categories":["LLM Study","AI Study"],"content":"LLM x AI 论文集","date":"2025-12-25","objectID":"/llm-x-ai/","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"2025 我最喜欢的 LLM x AI 论文集 2025年快过去了。 这一年，我几乎每天都有坚持读论文和分享论文， 获益匪浅。 下面是我整理的个人年度最喜欢论文集： ","date":"2025-12-25","objectID":"/llm-x-ai/:1:0","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"1、Test Time Scaling “Thinking” 到底是什么？ DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning s1: Simple test-time scaling ","date":"2025-12-25","objectID":"/llm-x-ai/:1:1","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"2. Efficient Reasoning “如果思考一种budget” L1: Controlling How Long A Reasoning Model Thinks With Reinforcement Learning Scalable Chain of Thoughts via Elastic Reasoning ","date":"2025-12-25","objectID":"/llm-x-ai/:1:2","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"3. Reasoning Analysis 该如何更好理解 “Reasoning” ？ (How) Do reasoning models reason? DeepSeek-R1 Thoughtology: Let’s about LLM reasoning Rethinking Reflection in Pre-Training Thinking vs. Doing: Agents that Reason by Scaling Test-Time Interaction ","date":"2025-12-25","objectID":"/llm-x-ai/:1:3","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"4. CLI Agent 2024年文章，但深度影响了2025。 SWE-agent: Agent-Computer Interfaces Enable Automated Software Engineering ","date":"2025-12-25","objectID":"/llm-x-ai/:1:4","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"5. LLM X RL Agentic 为此，我创造了一个词，“协议token” ReTool: Reinforcement Learning for Strategic Tool Use in LLMs ReSearch: Learning to Reason with Search for LLMs via Reinforcement Learning ReCall: Learning to Reason with Tool Call for LLMs via Reinforcement Learning ","date":"2025-12-25","objectID":"/llm-x-ai/:1:5","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"6. Parallel Reasoning 并行 reasoning，超越单线程的想象！ Learning Adaptive Parallel Reasoning with Language Models Multiverse: Your Language Models Secretly Decide How to Parallelize and Merge Generation Learning to Keep a Promise: Scaling Language Model Decoding Parallelism with Learned Asynchronous Decoding ","date":"2025-12-25","objectID":"/llm-x-ai/:1:6","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"7. RL X Reasoning, RLVR 这四篇，给 RL X Reasoning 极速升温+降温！ Reinforcement Learning for Reasoning in Large Language Models with One Training Example Absolute Zero: Reinforced Self-play Reasoning with Zero Data Learning to Reason without External Rewards Spurious Rewards: Rethinking Training Signals in RLVR ","date":"2025-12-25","objectID":"/llm-x-ai/:1:7","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"8. Agent, interaction Deep research agent 经验，记忆，交互，workflow，围绕 Agent KB: Leveraging Cross-Domain Experience for Agentic Problem Solving Alita-G: Self-Evolving Generative Agent for Agent Generation Sleep-time Compute: Beyond Inference Scaling at Test-time WebThinker: Empowering Large Reasoning Models with Deep Research Capability WebDancer: Towards Autonomous Information Seeking Agency ","date":"2025-12-25","objectID":"/llm-x-ai/:1:8","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"9. Risk modeling X LLM “让贝叶斯再次伟大！” Model Predictive Task Sampling for Efficient and Robust Adaptation Can Prompt Difficulty be Online Predicted for Accelerating RL Finetuning of Reasoning Models? ","date":"2025-12-25","objectID":"/llm-x-ai/:1:9","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"10. Multi-Agentic Multi Agent该怎么用？ Co-Evolving LLM Coder and Unit Tester via Reinforcement Learning CodeContests+: High-Quality Test Case Generation for Competitive Programming ","date":"2025-12-25","objectID":"/llm-x-ai/:1:10","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"11. Sentient Agent AI + 人文，情怀满满！ RLVER: Reinforcement Learning with Verifiable Emotion Rewards for Empathetic Agents Sentient Agent as a Judge: Evaluating Higher-Order Social Cognition in Large Language Models ","date":"2025-12-25","objectID":"/llm-x-ai/:1:11","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"12: LLM security and alignment 想要懂你真的不容易, LLM! Chain of Thought Monitorability: A New and Fragile Opportunity for AI Safety Emergent Misalignment: Narrow finetuning can produce broadly misaligned LLMs Thought Crime: Backdoors and Emergent Misalignment in Reasoning Models Natural Emergent Misalignment from Reward Hacking in Production RL Weird Generalization and Inductive Backdoors: New Ways to Corrupt LLMs ","date":"2025-12-25","objectID":"/llm-x-ai/:1:12","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["LLM Study","AI Study"],"content":"13. Model Steering 我要控制我自己，LLM! AxBench: Steering LLMs? Even Simple Baselines Outperform Sparse Autoencoders Persona Vectors: Monitoring and Controlling Character Traits in Language Models How to Train Your Advisor: Steering Black-Box LLMs with Advisor Models 最后，这个 list 是我的个人选择，因为时间精力有限，很多很好的工作，或许我都没有机会读到，感谢论文的作者们，带我领略智慧的风光！ 2025年快过去了，我很怀念它！ 2026年，会继续每天把我看到的最优秀的工作介绍给大家，很多深度的分析会专门放在订阅内容中，欢迎你成为我的订阅用户，我们一起成长！ 转载原文链接：2025 我最喜欢的 LLM x AI 论文集 ","date":"2025-12-25","objectID":"/llm-x-ai/:1:13","tags":["LLM Study","AI","LLM、AI论文"],"title":"转载：2025 我最喜欢的 LLM x AI 论文集","uri":"/llm-x-ai/"},{"categories":["Remote Work","远程工作"],"content":"远程工作、Remote Work","date":"2026-01-13","objectID":"/remotework/","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"远程工作资源合集 ","date":"2026-01-13","objectID":"/remotework/:1:0","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"远程工作的相关资料 远程工作的相关资料，包括工作保障、财务税务问题、团队管理问题等 ","date":"2026-01-13","objectID":"/remotework/:1:1","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"程序员工资地图 美国程序员工资地图 欧洲程序员工资地图 ","date":"2026-01-13","objectID":"/remotework/:1:2","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"程序员国内求职远程工作 电鸭社区 V2EX：酷工作板块 remote-jobs-cn:国内远程办公招聘 电报：远程工作者 电报：国内外远程技术岗位 电报：远程工作招聘|TG招聘 ","date":"2026-01-13","objectID":"/remotework/:1:3","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"程序员找国外远程工作的资源网站 Github Remote-friendly companies —— 一份科技领域及周边行业中支持半远程至全远程办公的公司清单 Github Awesome Remote Job —— 精选优质远程工作和资源列表 LinkedIn —— 全球最大的职业社交平台，对找国外工作尤其重要。建议完善英文简历，积极与目标公司的招聘者建立联系 Twitter / X —— Twitter推出了求职招聘的功能，有许多科技公司和创业公司会在上边发布职位信息，你也可以关注感兴趣的公司和招聘者，及时获取工作机会 remoteok —— 最大的远程工作平台之一，每天更新大量远程职位，包括软件开发、设计、产品等岗位，可以按技能、薪资范围筛选 HNHIRING —— 汇集了 Hacker News 上\"Who is hiring?“帖子中的所有工作机会，主要面向技术岗位，很多是知名科技公司的职位 frontendremotejobs —— 专注于前端开发远程工作机会的求职网站，包括 React、Vue、Angular 等各类前端技术栈的职位 flexjobs —— 付费的远程工作平台，提供经过筛选的高质量远程职位，覆盖多个行业，包括技术、设计等领域 remote —— 提供全球远程工作机会，除了技术岗位外还包括市场、设计等多个领域，同时提供远程工作相关的资源和建议 高端remote工作 —— 面向顶尖自由职业者的平台，提供高薪远程工作机会，但加入平台需要通过严格的技术测试 Remotive —— 专注于远程工作的求职平台，提供详细的公司介绍和职位描述，支持按技能、地区、公司规模等多维度筛选 日本IT相关岗位 —— 专注于日本技术职位的求职网站，提供远程和现场工作机会，特别适合想进入日本IT行业的开发者 weworkremotely —— 老牌远程工作平台，每月有数百万访问量，提供质量较高的远程工作机会，特别是技术类岗位 Remote Handbook —— Remote.com 公司的远程工作手册，详细介绍了远程工作的最佳实践、工具和方法论 Vue技术栈 相关远程 —— 专注于 Vue.js 技术栈的工作机会，包括远程和现场职位，是 Vue 开发者找工作的重要平台 Three.js 论坛发布的前端相关职位招聘 —— Three.js 官方社区的招聘板块，主要面向 3D 图形和 WebGL 开发者 一亩三分地 —— 北美最大的华人求职交流社区，提供大量海外工作机会和求职经验分享 JavaScript技术栈 —— 专注于 JavaScript 生态系统的工作机会，包括前端、Node.js、全栈开发等职位 Freelancer 号称是:“全球最大的自由职业和众包市场” —— 全球性的自由职业平台，提供各类项目外包机会，支持按小时或项目计费 Vercel的谁在招人讨论区 —— Next.js 官方社区的招聘讨论区，主要面向 React 和 Next.js 开发者 欧洲的远程工作 —— 专注于欧洲市场的远程工作机会，特别是波兰、德国等地区的技术职位 创业公司的远程机会 —— 前身是 AngelList Talent，汇集了大量创业公司的工作机会，包括远程职位 润拉拉:移民找工作、远程工作 —— 面向中国开发者的海外工作信息平台，提供移民、远程工作等相关资讯 个人外包项目 —— 全球最大的自由职业平台之一，提供各类远程项目机会，适合寻找短期或长期外包项目 github远程文化介绍（全员远程的上市公司） —— GitLab 公司的远程工作文化手册，详细介绍了如何建立和维护远程团队 RustJobs —— 专注于 Rust 语言相关的工作机会，包括远程职位，是 Rust 开发者的重要求职平台 GitLab 公司远程相关岗位 —— GitLab 公司的招聘页面，作为全远程公司的标杆，提供各类远程工作机会 Web3相关的远程工作 —— 汇集 Web3、区块链、加密货币等领域的远程工作机会 web3相关工作 —— 专注于加密货币和区块链领域的工作机会，包括开发、产品、运营等各类职位 Web3-Recruitment-Website:Web3招聘平台、频道汇总 —— Web3 领域招聘资源的综合汇总，包括各类招聘平台、社区和渠道 ","date":"2026-01-13","objectID":"/remotework/:1:4","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"程序员海外工作/英文面试手册 Programmers-Overseas-Job-Interview-Handbook:程序员海外工作/英文面试手册 ","date":"2026-01-13","objectID":"/remotework/:1:5","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"Reddit上有个remotework版块 分享有关远程或分布式团队工作的新闻、经验、提示、技巧和软件的团队、公司和个人提供的地方。感兴趣的小伙伴们可以关注下。 Reddit remote work 版块 Best online resources for finding remote work? ","date":"2026-01-13","objectID":"/remotework/:1:6","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"其他 前端程序员出海花果山大圣 2024 年在线寻找远程工作的 25+ 个最佳网站 2024 年 65 个最佳远程工作网站 ","date":"2026-01-13","objectID":"/remotework/:1:7","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["Remote Work","远程工作"],"content":"远程公司、工作手册 GitLab GitLab 远程文化手册 GitLab 公司GitHub的工作文档 Basecamp 原 37signals Basecamp 内部交流指南 Basecamp 出版的书籍 REWORK: 重来 ","date":"2026-01-13","objectID":"/remotework/:1:8","tags":["Remote Work","远程工作"],"title":"远程工作资源合集","uri":"/remotework/"},{"categories":["LLM Study","AI Study"],"content":"MCP 和 Skills 到底什么区别","date":"2026-01-30","objectID":"/mcpvsskills/","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"MCP 和 Skills 到底什么区别？一篇文章说清楚 转载声明：本文转载自 宝玉 @dotey 的 X Article，原文链接：https://x.com/dotey/status/2014025984895258934 作者：宝玉 (@dotey) 日期：2025年1月22日 一句话解释 MCP 和 Skills 的区别：如果 AI Agent 是操作系统，MCP 就是 USB 协议，Skills 就是应用程序。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:0","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"一位开发者的困惑 有位网友私信问我：“MCP 是不是已经过时了？现在应该全用 Skills？” 这个问题可能很多人都好奇。我理解这种焦虑。AI Agent 工具圈每隔两周就会冒出新东西，每次新东西出来，就有人喊旧的\"已死\"。 对于喜欢 Skills 的人可能会想：我写个脚本自己用，干嘛搞那么复杂？我就是要编码一下我的工作流程，让 AI 能理解我们团队的做事方式，Skills 写起来简单，放个文件就行，何必折腾 MCP Server？ 喜欢 MCP 的人则会认为：我要做一个服务，让所有人都能用，不只是我自己，不只是我团队。我要让用户输入一个 URL 就能用，甚至未来什么都不用装，直接问 AI\"帮我订机票\"就行。 仔细看其实这两拨人的需求完全不一样。 不是功能差异，是分发方式的差异。Skills 是给自己人用的，MCP 是给全世界用的。 想象你是一家卖服务的公司。你服务的安装说明怎么写？如果你是以 Skills 的方式发布，说明就要说清楚\"把 SKILL.md 文件复制到特定目录\"，可能还需要特定脚本的运行权限，用户都不一定敢安装。但如果是\"输入这个 URL\"或者\"直接跟 AI 说帮我用这个服务\"，也不需要你在本机安装个 nodejs/python，那就好多了。 但光理解定位还不够。这两个东西在技术层面有本质区别，直接影响你的使用体验和成本。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:1","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"MCP：AI 世界的 USB 协议 还记得十年前的充电线吗？苹果用 Lightning，安卓用 Micro USB，笔记本用各种奇形怪状的电源头。出门一趟，包里塞满五六根线。 AI 行业在 2024 年之前也是这样。 你想让 Agent 读取 GitHub 仓库？写一套对接代码。想让 ChatGPT 查数据库？再写一套。想让 Cursor 发 Slack 消息？又是一套。10 个 AI 应用要连 20 个工具，理论上需要 200 个定制集成。每家都在重复造轮子，开发者苦不堪言。 2024 年 11 月，Anthropic 开源了 MCP（Model Context Protocol，模型上下文协议）。它做的事情，和 USB-C 统一充电接口一模一样： 定义一套标准协议，让任何 AI 都能即插即用地连接任何工具。 有了 MCP，10 个 AI 应用 + 20 个工具 = 30 个 MCP 实现，而不是 200 个定制集成。数学上叫把 M×N 问题变成了 M+N 问题，实践中意味着开发成本断崖式下降。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:2","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"MCP 的致命问题：上下文爆炸 但 MCP 有一个严重的副作用：吃掉你的上下文窗口。 每个 MCP Server 连接到 AI 时，必须把所有工具的定义（名称、描述、参数、示例）一次性塞进上下文。一个工具的定义大概 500-800 tokens，一个 MCP Server 通常有 10-20 个工具。 来看几个真实数据： GitHub MCP Server：27 个工具，消耗约 18,000 tokens Playwright MCP Server：21 个工具，消耗约 13,600 tokens mcp-omnisearch：20 个工具，消耗约 14,200 tokens 有开发者配了 7 个 MCP Server，还没开始对话，上下文就被吃掉了 67,000 tokens —— 占 AI 上下文窗口的 33%。更夸张的案例是 82,000 tokens，占 41%。 这意味着什么？你问 AI “2+2 等于几”，它回答 “4” 只需要 5 个 token，但工具定义已经消耗了 15,000 tokens。简单问题的成本被放大了 3000 倍。 更糟糕的是，当上下文被工具定义挤占后，AI 选错工具、传错参数的概率会显著上升。实践中，连接 2-3 个以上的 MCP Server，工具使用准确性就会明显下降。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:3","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"Claude Code 的解法：Tool Search Anthropic 意识到了这个问题。2025 年 1 月，Claude Code 推出了 Tool Search 功能： MCP 工具不再预加载，而是按需发现 当工具定义超过上下文的 10% 时自动启用 AI 需要用某个工具时，先搜索再加载 效果立竿见影：从 77,000 tokens 降到 8,700 tokens，减少 85%。 但这只是在给 MCP 打补丁。问题的根源在于：MCP 的设计假设是\"把所有工具摆出来让 AI 挑\"，这在工具数量少的时候没问题，工具多了就撑不住。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:4","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"Skills：渐进式披露的操作手册 Skills 从一开始就采用了不同的设计哲学：渐进式披露（Progressive Disclosure）。 怎么理解呢？ 想象你招了个新员工。传统做法是入职第一天把公司所有流程文档、规章制度、操作手册全部打印出来堆在他桌上，这就是 MCP 的做法。而 Skills 的做法是：先给一份简短的岗位说明，等他遇到具体问题时，再告诉他去翻哪本手册的哪一页。 技术上，Skills 是这样实现的： 第一层：元数据（启动时加载） 只有名称和简短描述 每个 Skill 约 100 tokens 装 100 个 Skill 也只占 10,000 tokens 第二层：完整指令（相关时加载） 当 AI 判断某个 Skill 与任务相关时，才读取完整的 SKILL.md 建议控制在 5,000 tokens 以内 第三层：参考资料（需要时加载） 详细的技术文档、API 说明、示例代码 按需读取，用多少加载多少 理论上可以包含无限内容 这意味着：一个 Skill 可以打包整套 API 文档、完整的数据字典、几百页的参考手册，但只要任务不需要，这些内容就永远不会占用上下文。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:5","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"Skills 的杀手锏：自带脚本 Skills 还有一个很多人忽略的能力：它可以自带可执行脚本。 一个典型的 Skill 文件夹结构是这样的： my-skill/ ├── SKILL.md # 核心指令 ├── scripts/ # 可执行脚本 │ ├── validate.py │ ├── generate.sh │ └── process.js ├── references/ # 参考文档 └── assets/ # 模板、配置文件 关键来了：当 AI 运行 scripts/validate.py 时，脚本代码本身不会加载到上下文，只有执行结果会返回。 这是什么概念？ 假设你有一个 500 行的 Python 脚本，用来处理 PDF 表单。用传统方式，AI 要么自己写代码（消耗大量 tokens 生成），要么读取你的脚本再执行（脚本内容占用上下文）。而用 Skills，AI 直接运行预写好的脚本，整个过程可能只消耗 50 tokens 的输出结果。 脚本执行 = 零上下文成本 + 确定性结果 更重要的是：这些脚本通过 Agent 内置的 bash 工具执行，不需要 MCP。 Skills 支持的脚本语言包括 Python、Bash、JavaScript 等，基本上你系统能跑的都能用。这意味着： 文件读写？Skill 脚本搞定 数据处理？Skill 脚本搞定 格式转换？Skill 脚本搞定 本地 API 调用？Skill 脚本搞定 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:6","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"MCP vs Skills：什么时候需要什么？ 现在我们可以重新审视这两个概念的定位了。 特性 MCP Skills 类比 USB 协议 应用程序 核心能力 连接外部系统 编码专业知识 工具来源 外部 MCP Server 内置工具 + 自带脚本 上下文消耗 预加载，成本高 渐进式披露，按需加载 网络访问 ✅ 支持 ❌ 仅本地执行 分发方式 URL 接入，面向外部用户 文件复制，面向内部团队 适用场景 远程 API、实时数据、对外服务 本地流程、专业方法论、内部工具 有一句话说得很精辟：Skills 描述工作流程，MCP 提供执行引擎。但很多时候，操作系统自带的引擎就够用了。 这就像 GitHub Actions：工作流文件（相当于 Skills）定义了构建、测试、部署的步骤，但实际执行的还是 bash 命令。YAML 就像菜谱，写清楚先放油、再下葱、最后翻炒，但菜谱本身不会做菜，真正掌勺的是厨师。 问题是：Agent 这个\"操作系统\"本身就自带了 bash、read、write 等基础工具。对于大量本地任务，Skills + 内置工具就能完成，根本不需要额外的 MCP Server。 还有个类比我觉得很贴切：Skills 像 Slack 里的斜杠指令（slash commands）。你公司 Slack 里可能有几十个 slash commands，大部分你从来没用过，但对特定的人特定的场景很有用。这就是 Skills 的定位：内部工具，按需使用。 但你不可能把 slash commands 卖给外部用户。要对外，得用 MCP。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:7","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"随着 Skills 普及，MCP 的需求会大幅减少 这是一个正在发生的趋势。 想想看，什么时候你真正需要 MCP？ 需要 MCP 的场景： 连接远程 CRM 系统获取客户数据 调用第三方 SaaS API（Slack、Notion、Jira） 查询云端数据库 访问需要认证的外部服务 做一个服务让外部用户都能用 不需要 MCP 的场景： 读写本地文件 → bash + Skill 脚本 处理 PDF/Word/Excel → Skill 脚本 运行代码分析 → Skill 脚本 执行 Git 操作 → Skill 脚本 生成图表和可视化 → Skill 脚本 优化自己或团队的工作流 事实上，Anthropic 的工程博客提到：他们用\"代码执行 + MCP\"的方法，把一个 150,000 token 的工作流压缩到了 2,000 tokens —— 核心思路就是让 AI 写代码调用工具，而不是预加载所有工具定义。 这正是 Skills 的 design 方向：用脚本封装能力，用渐进式披露管理知识，最大限度减少上下文消耗。 未来的格局可能是这样的： 少数通用 MCP Server：处理远程连接（数据库、云 API、SaaS 集成） 大量 Skills：编码专业知识和本地工作流 两者在必要时协作，但 Skills 会承担绝大部分\"教 AI 怎么做事\"的工作。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:8","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"一个真实案例：自动发布 X Article 这是一个真实发生的演进过程，完美展示了从 MCP 到 Skills 的转变。 需求： 把 Markdown 文章自动发布到 X（Twitter）的长文功能 X Article。 方案一：Playwright MCP 王树义老师（@wshuyi）开发了 x-article-publisher-skill，流程是： Markdown 文件 -\u003e Python 脚本解析 -\u003e Playwright MCP 操作浏览器 -\u003e X Articles 编辑器 -\u003e 保存草稿 提示词很简洁，功能也很强大。但问题来了：上下文消耗得飞快。 Playwright MCP 有 22 个工具，光工具定义就占用约 8,000-10,000 tokens。更要命的是，每次浏览器交互，MCP 都要返回页面的 accessibility tree（无障碍树）快照。发布一篇文章，每一步都是一次 MCP 交互，结果一篇文章发完，上下文可能已经用掉 50,000+ tokens。 方案二：Skills + CDP 脚本（我的改进版本） 我把 Playwright MCP 部分完全改成了脚本，做成了 baoyu-post-to-x。 核心变化： 脚本直接调用 Chrome CDP（Chrome DevTools Protocol），绕过 MCP 脚本自己完成所有浏览器操作：打开页面、填充内容、上传图片、保存草稿 只返回最终结果给 Agent：“发布成功，草稿链接：xxx” 整个过程，AI 只需要做一件事：调用脚本。上下文消耗可能只有几百 tokens。 为什么差距这么大？ 维度 Playwright MCP Skills + CDP 脚本 工具定义 ~10,000 tokens 0 (脚本不需要工具定义) 每次交互 返回页面快照 (数千 tokens) 无中间交互 AI 参与度 每一步都要 AI 决策 只需调用一次脚本 总消耗 50,000+ tokens 几百 tokens 关键洞察：MCP 的设计是让 AI 一步步操作，每一步都要理解及执行；而脚本的设计是把整个流程封装，AI 只需要说\"开始\"和\"结束\"。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:9","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"详细分析 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:10","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":["LLM Study","AI Study"],"content":"写在最后：回到那个私信 所以我给那位读者的回复是： MCP 没死。Skills 也很有用。它们解决的是不同问题。 MCP 是 USB 协议，定义了连接标准；Skills 是应用程序，把专业知识打包成操作手册。 Skills 的两大杀手锏 —— 渐进式披露和脚本执行 —— 让它能独立完成大量任务，不依赖 MCP。 到底怎么选？问自己三个问题： 谁来用？ 团队内部用选 Skills，给外部用户用选 MCP。 怎么分发？ 接受复制文件选 Skills，希望输入 URL 选 MCP。 解决什么问题？ 编码领域知识选 Skills，连接外部服务选 MCP。 最佳实践是两者配合：用 Skills 编码你的领域知识，用 MCP 连接外部服务。 对于开发者：优先用 Skills 封装工作流，逻辑用脚本，只在必须连远程系统时用 MCP。如果你只能选一个先学，选 Skills。它更轻量、高效，能解决日常大部分问题。 💡 个人思考：这篇文章很好地解释了 MCP 和 Skills 的定位差异。作为 AI 开发者，理解这两者的适用场景，能帮助我们在构建 AI Agent 时做出更明智的技术选择。 ","date":"2026-01-30","objectID":"/mcpvsskills/:1:11","tags":["MCP","Skills","AI","LLM"],"title":"转载：MCP 和 Skills 到底什么区别？","uri":"/mcpvsskills/"},{"categories":null,"content":"✋ Hi，小伙伴们你们好呀！我是 SincereCSL 一名前端开发工程师，热爱探索新技术，喜欢在空间时间中学习与沉淀。 技术狂热爱好者，喜欢逛 Hacker News、TechCrunch、GitHub、Stack Overflow、YouTube 等技术社区，持续学习前沿技术。在 GitHub 开源社区积极分享技术成果，乐于钻研、实践并推动技术创新。热爱 阅读、篮球，以技术驱动成长，持续突破自我。 希望不断学习，不断成长。期望能在忙碌中持续提升自己，写好每一行代码，过好每一天。 现阶段的目标是能够在忙碌地闲隙里多学习、不断思考，多阅读写作。 ","date":"2023-01-11","objectID":"/about/:1:0","tags":null,"title":"关于 SincereCSL","uri":"/about/"},{"categories":null,"content":"📡 个人网络信息 Email： SincerestCSL@gmail.com Twitter GitHub 豆瓣书单 ","date":"2023-01-11","objectID":"/about/:1:1","tags":null,"title":"关于 SincereCSL","uri":"/about/"},{"categories":null,"content":"👨‍💻 个人简介 我是一名前端开发工程师，拥有 7 年 Web 前端开发经验，熟练掌握主流前端技术与工程化工具，具备从 0 到 1 独立完成项目的能力，也擅长协作与推动项目高质量上线交付。拥有广泛的技术知识和实践经验并有丰富的项目实践经验。我深入理解这些框架的核心原理和工作机制，可以独立地设计和构建复杂的前端应用程序。 🔧 技术栈 语言与核心技术：JavaScript、TypeScript、HTML5、CSS3、Sass、Less 框架与类库：Vue3、Vue2、React16+、UmiJS、AngularJS（1.x）、jQuery UI 框架：Element Plus、Element UI、Ant Design、Bootstrap 等 构建工具与工程化：Webpack、Vite、ESLint、Prettier、Stylelint、MockJS 后端基础能力：Node.js、Go、MongoDB、MySQL、Docker 跨平台桌面开发：了解 CEF 框架，掌握 JS 与 C++ 的交互机制 图形图像与可视化(感兴趣)：WebGL、WebGPU、Canvas、SVG、CesiumJS（三维可视化） 🧠 项目经验与优势 熟悉组件化开发、响应式设计、模块化与规范化流程 能快速搭建前端开发体系，提升团队开发效率与代码质量 熟悉业务系统开发与维护，参与多个核心平台前端架构设计 擅长构建大屏可视化展示平台与数据图表系统 具备一定的后端协作与系统理解能力，便于快速集成上线 ","date":"2023-01-11","objectID":"/about/:1:2","tags":null,"title":"关于 SincereCSL","uri":"/about/"},{"categories":null,"content":"✅ 能力总结 注重代码质量与开发规范，熟悉团队协作流程 善于知识分享，具备较强文档编写与技术表达能力 喜欢钻研底层原理，追求性能优化与可维护性 热衷学习新技术，具备持续学习与快速上手能力 希望能在未来的技术旅程中，与更多优秀的伙伴一起成长，一起打造出更有温度的产品与技术成果！ 关于本站 主要用来记录我自己学习、生活与零碎的一些想法。基于稳定性和自由度考虑决定使用 Hugo 生 成自己的静态网页，托管于 GitHub。SincereCSL 的名字是我个人比较喜欢的一个单词Sincere与我的中文名首字母组合起来的， 希望每天都提醒着自己真诚地对待每位人和世界，坦率地去做自己喜欢的事，不断去学习、体验与挑战新的事物，提升自己。 希望自己能多输入一些新的知识和想法，多写一些小文章。 ","date":"2023-01-11","objectID":"/about/:1:3","tags":null,"title":"关于 SincereCSL","uri":"/about/"},{"categories":null,"content":"时不时更新中👀 … ","date":"2022-02-27","objectID":"/links/:0:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"博客 Martin Fowler The Clean Code Blog Joel on Software Paul Graham Essays Julia Evans 酷壳 – CoolShell 阮一峰的个人网站 面向信仰编程 冰霜之地 当然我在扯淡 宝玉的分享 justjavac(迷渡) 小胡子哥的个人网站 勾三股四 是不是很酷:微信公众号 张鑫旭-鑫空间-鑫生活 云风的 BLOG 当然我在扯淡 廖雪峰的官方网站 鸟窝 离别歌 美团技术团队 ","date":"2022-02-27","objectID":"/links/:1:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"文章 40 years of programming 别让自己“墙”了自己 如何超过大多数人 Teach Yourself Programming in Ten Years What are some of the most basic things every programmer should know? how to read an academic article How To Ask Questions The Smart Way ","date":"2022-02-27","objectID":"/links/:2:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"英语 BBC Learning English 英语自学 英语进阶指南 人人都能用英语-李笑来 ","date":"2022-02-27","objectID":"/links/:3:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"英语播客 以下是一些专为初学者设计的英语播客，语速较慢且内容简单易懂： 6 Minute English - BBC制作的简短英语学习节目，每集仅6分钟，针对初中级学习者，内容通俗易懂 The English We Speak - BBC出品，专注于日常英语短语和俚语学习，每集3-4分钟，非常适合初学者 ESLPod - 专为英语学习者设计的播客，语速缓慢且解释详细，对初学者非常友好 Speak English Now - 通过有趣的故事和对话帮助学习者自然地学习英语，强调听力输入 All Ears English - 轻松有趣的英语学习播客，专注于日常实用对话和美国文化，设有专门的初学者内容 Coffee Break English - 短小精悍的英语学习节目，像喝咖啡休息一样轻松学习英语，分级教学 Elementary Podcasts - 英国文化协会出品，专为初学者设计的对话和故事，配有完整文字稿 以下是一些优质英语播客，非常适合提升英语听力和学习地道表达： Luke’s ENGLISH Podcast - 由英语老师Luke主持，通过轻松有趣的方式教授英语表达和文化，适合中高级学习者 This American Life - 美国国宝级广播节目，每期围绕一个主题讲述多个真实故事，语速适中，表达地道 Lex Fridman Podcast - MIT研究员主持的深度访谈节目，邀请科技、科学、艺术等领域的顶尖人物对话 The Tim Ferriss Show - 畅销书作家蒂姆·费里斯访谈各行业精英，解析成功经验和生活习惯 Up First from NPR - NPR每日新闻摘要，10-15分钟了解全球重要事件，语速适中清晰 Serial - 沉浸式叙事调查性节目，每季深入剖析一个真实故事，叙事性强 Planet Money - 用生动方式解释复杂经济概念，故事性强，适合各级别学习者 TED Talks Daily - 每日更新TED演讲，涵盖广泛话题，多数演讲语速适中 The Allusionist - 探索语言起源和演变的有趣节目，适合对语言学感兴趣的学习者 Grammar Girl - 简短实用的英语语法和写作技巧，特别适合想提高写作的学习者 ","date":"2022-02-27","objectID":"/links/:4:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"程序员相关播客 Web Worker-前端程序员都爱听 硬地骇客 浪说播客 代码之外 Beyond code Lex Fridman Podcast JS Party: JavaScript, CSS, Web Development The Changelog: Software Development, Open Source CoRecursive: Coding Stories Serial This Is Actually Happening This American Life The Indicator from Planet Money ","date":"2022-02-27","objectID":"/links/:5:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"写作 Technical Writing Courses: Google 技术文档的课程 The Day You Became A Better Writer ","date":"2022-02-27","objectID":"/links/:6:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"工具 Language Reactor 一款可以加载双语字幕的插件 Bypass Paywalls Clean 【Chrome、Firefox插件】支持多达 500+网站的付费墙绕过，默认包括南方周末，路透社，经济学人，纽约时报，华尔街日报等大部分主流媒体。 Relingo 可以将自己不懂生词和难词，自动标示和翻译 Trancy 支持YouTube、NetFlix双语字幕、字幕阅读模式、划词翻译 Medium Parser Chrome 插件 可以绕过 Medium 的付费墙 查看付费文章 ","date":"2022-02-27","objectID":"/links/:7:0","tags":null,"title":"Links","uri":"/links/"}]