[{"categories":["笔记"],"content":"cool文化","date":"2022-02-10","objectID":"/cool/","tags":["content","Markdown"],"title":"今天的你Cool嘛","uri":"/cool/"},{"categories":["笔记"],"content":"Amazon 创始人杰夫·贝索斯认为很酷 Rudeness is cool. 野蛮不酷 Defeating tiny guys is not cool. 打败弱者不酷 Close-following is not cool. 跟随别人不酷 Young is cool. 年青很酷 Risk taking is cool. 冒险很酷 Winning is cool. 胜利很酷 Polite is cool. 有礼貌很酷 Defeating bigger, unsympathetic guys is cool. 打败不值得同情的大公司很酷 Inventing is cool. 创新很酷 Explorers are cool. 开拓很酷 Conquerors are not cool. 征服不酷 Obsessing over competitors is not cool. 关注竞争对手不酷 Empowering others is cool. 帮助别人很酷 Capturing all the value only for the company is not cool. 复制别人不酷 Leadership is cool. 引领别人很酷 Conviction is cool. 有坚定的信仰很酷 Straightforwardness is cool. 直率很酷 Pandering to the crowd is not cool. 迎合大众不酷 Hypocrisy is not cool. 虚假不酷 Authenticity is cool. 诚实很酷 hinking big is cool. 着眼长远很酷 The unexpected is cool. 意想不到很酷 Missionaries are cool. 传教士很酷 Mercenaries are not cool. 雇佣兵不酷 来源：What Jeff Bezos Thinks Is Cool ","date":"2022-02-10","objectID":"/cool/:0:0","tags":["content","Markdown"],"title":"今天的你Cool嘛","uri":"/cool/"},{"categories":["笔记"],"content":"Google 评分卡、Google SRE自评技术或技能领域","date":"2023-09-25","objectID":"/googlescorecard/","tags":["content","Markdown"],"title":"Google 评分卡","uri":"/googlescorecard/"},{"categories":["笔记"],"content":"Google 评分卡 0 - 对于相关的技术领域还不熟悉 1 - 可以读懂这个领域的基础知识 2 - 可以实现一些小的改动、清楚基本原理，并能够在简单的指导下自己找到更多的细节 3 - 基本精通这个技术领域，完全不需要别人的帮助 4 - 对这个技术领域非常熟悉和舒适，可以应对和完成所有的日常工作 对于软件领域: 有能力开发中等规模的程序，能够熟练和掌握并使用所有语言特性，而不是需要翻书，并且能够找到所有的冷知识 对于系统领域：掌握网络和系统管理的很多知识，并能够掌握一些内核知识以运维一个小型网络系统，包括恢复、调试和能解决一些不常见的故障 5 - 对于该技术领域有非常底层的了解和深入的技能 6 - 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构 7- 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作 8 - 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施 9 - 能够在该技术领域出一本经典的书，并和标准委员会的人一起工作制定相关技术标准和方法 10 - 在该领域写过一本书，被业界尊为专家，并是该技术的发明人 ","date":"2023-09-25","objectID":"/googlescorecard/:1:0","tags":["content","Markdown"],"title":"Google 评分卡","uri":"/googlescorecard/"},{"categories":["笔记"],"content":"Google SRE自评技术或技能领域 TCP/IP Networking（OSI stack,DNS etc） Unix/Linux internals Unix/Linux Systems administration Algorithms and Data Structures C/C++ Python Java Perl Go Shell Scripting（sh,Bash,ksh,csh） SQL and/or Database Admin Scripting language of your choice（not already mentioned）_________ People Management Project Management ","date":"2023-09-25","objectID":"/googlescorecard/:2:0","tags":["content","Markdown"],"title":"Google 评分卡","uri":"/googlescorecard/"},{"categories":["笔记"],"content":"The Learning Pyramid ","date":"2023-09-25","objectID":"/googlescorecard/:3:0","tags":["content","Markdown"],"title":"Google 评分卡","uri":"/googlescorecard/"},{"categories":["Google Search"],"content":"Google","date":"2025-01-04","objectID":"/googlesearch/","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"Google 搜索技巧 ","date":"2025-01-04","objectID":"/googlesearch/:1:0","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"1. 基础搜索运算符 精确匹配搜索 - 引号 \"\" 当你需要搜索完全匹配的词组时使用 例如： \"最好的编程语言\" - 完整匹配这个短语 \"python error\" - 精确匹配错误信息 \"how to\" \"python\" - 组合多个精确匹配 适用场景： 搜索特定的错误信息 查找精确的引用或句子 寻找特定的标题或名称 搜索特定的代码片段 使用技巧： 可以组合多个引号搜索 引号内的空格会被保留 标点符号最好也包含在内 排除特定词 - 减号 - 在关键词前加减号可以排除包含该词的结果 实例： java -咖啡 (搜索Java编程而非咖啡) python -蛇 -宠物 (编程相关) 苹果 -手机 -水果 (公司相关) 使用技巧： 减号必须紧贴要排除的词 可以同时使用多个减号 可以排除特定网站：python -site:csdn.com 可以排除特定文件类型：教程 -filetype:pdf 常见应用： 去除购物网站：-site:taobao.com -site:jd.com 去除视频站点：-site:bilibili.com -site:youtube.com 排除培训广告：-培训 -招生 -报名 站内搜索 - site: 限定在特定网站内搜索内容 基本语法：site:网站域名 搜索词 实例： site:zhihu.com 人工智能 site:edu.cn 论文 site:gov.cn 政策 高级用法： 指定多个站点： site:(github.com OR stackoverflow.com) python错误 限定子域名： site:docs.python.org 教程 site:help.github.com 指南 组合其他运算符： site:edu.cn filetype:pdf \"机器学习\" site:github.com \"README.md\" \"最佳实践\" 实用技巧： 学术搜索：site:edu.cn OR site:ac.cn 官方文档：site:docs.*.com 技术问答：site:(stackoverflow.com OR github.com) 政府文件：site:gov.cn filetype:pdf ","date":"2025-01-04","objectID":"/googlesearch/:1:1","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"2. 高级搜索技巧 文件类型搜索 - filetype: 搜索特定格式的文件 常用文件类型： filetype:pdf - PDF文档 filetype:ppt - 演示文稿 filetype:doc - Word文档 filetype:xls - Excel表格 filetype:txt - 文本文件 filetype:zip - 压缩文件 实例： filetype:pdf python教程 site:edu.cn filetype:ppt 项目管理 filetype:doc 简历模板 高级用法： 多文件类型：(filetype:doc OR filetype:pdf) 开发文档 排除某类文件：开发文档 -filetype:pdf 组合站点搜索：site:github.com filetype:md README 通配符搜索 - * 用星号代替任意文字 使用场景： 记不清完整词句时 搜索变体形式 查找特定模式 例子： 如何成为一名*工程师 * 的使用方法 2024年*趋势 高级应用： 歌词搜索：\"我爱* 就像*\" 成语搜索：\"一* 一*\" 标题匹配：\"如何提高* 效率\" 多关键词搜索 - OR 或 | 搜索多个可能的关键词 使用大写的OR或竖线符号 实例： 前端 OR 后端 开发 Python | Java | C++ 教程 可以组合多个条件： (Python | Java) site:github.com (北京 | 上海 | 深圳) 招聘 标题搜索 - intitle: 和 allintitle: intitle: - 搜索标题中包含特定词的页面 allintitle: - 搜索标题中包含所有指定词的页面 使用方法： intitle:python 教程 - 标题含\"python\" allintitle:python 入门 教程 - 标题同时含这三个词 实用场景： 找教程：intitle:教程 python 找文档：intitle:documentation react 找视频：intitle:视频教程 golang 网址搜索 - inurl: 和 allinurl: inurl: - URL中包含特定词 allinurl: - URL中包含所有指定词 应用示例： inurl:blog python - URL含\"blog\" allinurl:github python project 实用技巧： 找博客：inurl:blog site:medium.com 找项目：inurl:project site:github.com 找文档：inurl:docs python 正文内容搜索 - intext: 和 allintext: intext: - 正文中包含特定词 allintext: - 正文中包含所有指定词 使用场景： intext:机器学习 算法 allintext:python 错误 解决方案 组合应用： intext:面试题 site:zhihu.com allintext:源码分析 site:github.com 相关词搜索 - related: 和 AROUND(n) related: - 查找相关网站 AROUND(n) - 查找两个词距离在n个词以内的结果 实例： related:python.org - Python相关网站 python AROUND(3) 教程 - 两词相距3个词内 实用场景： 寻找替代网站：related:stackoverflow.com 寻找相近内容：javascript AROUND(5) framework 时间和数字范围搜索 数字范围 ..： 手机 3000..5000 元 显示器 24..32 英寸 2020..2024 技术趋势 时间范围： before:2024-01-01 - 某日期之前 after:2023-01-01 - 某日期之后 组合示例： after:2023-01-01 before:2024-01-01 编程语言排行 after:2024 site:github.com \"machine learning\" ","date":"2025-01-04","objectID":"/googlesearch/:1:2","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"3. 实用搜索命令 计算和单位转换 数学计算： 基础运算：2 * 3 + 4 高级计算： sin(30) + cos(60) sqrt(144) 2^10 (15% of 80) * 2 log(1000) 5! 单位换算： 货币：100 USD to CNY 长度：5 miles to km 面积：100 平方米 to 平方英尺 重量：50 公斤 转 磅 温度：32F to C 时间和日期查询 时区转换： 北京时间 3pm in New York Tokyo time in London 日期计算： Easter 2024 days between 2024-01-01 and 2024-12-31 weeks until Christmas 日出日落：sunrise/sunset [城市名] 节假日：[节日名] [年份] 实时信息查询 天气信息： 天气 [城市名] [城市]未来一周天气 weather alerts [地区] 交通状态： flight [航班号] [城市]实时路况 自然灾害： earthquakes near [地点] 台风实时路径 股票市场： [股票代码] stock [公司名] stock price 健康相关查询 营养成分： calories in apple protein in chicken breast 运动消耗： calories burned running 30 minutes calories walking 5km BMI计算： BMI calculator healthy weight for 175cm 实用工具命令 IP地址查询： what is my ip ip location 8.8.8.8 网站状态： is facebook down site status github.com 字符计数： word count \"your text here\" character count \"测试文本\" 娱乐功能 掷骰子： roll a die roll 2d6 随机数： random number 1-100 random number generator 游戏： play pacman play snake play solitaire 紧急信息查询 天气预警： weather alerts near me 台风实时路径 地震信息： earthquakes near me recent earthquakes in Japan 急救信息： first aid for burns CPR steps ","date":"2025-01-04","objectID":"/googlesearch/:1:3","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["Google Search"],"content":"4. 搜索技巧组合使用 实例一：学术研究 论文搜索组合： site:edu.cn filetype:pdf \"机器学习\" after:2023 -\"课程设计\" 这个组合可以： 限定在教育网站搜索 只搜索PDF格式 精确匹配\"机器学习\" 限定2023年后的内容 排除课程设计类文档 实例二：技术问题排查 错误信息搜索： site:(stackoverflow.com OR github.com) \"RuntimeException\" \"解决方案\" after:2023 搜索策略： 在主流技术社区中搜索 精确匹配错误信息 查找最新的解决方案 支持中英文混合查询 实例三：产品调研 产品评测搜索： (小米 OR 华为) 手机 15000..20000 评测 -二手 filetype:pdf after:2024-01 搜索要点： 指定多个品牌 设定价格范围 排除二手信息 限定最新评测 专业评测文档 实例四：编程资源查找 开发文档搜索： site:github.com \"React Native\" (tutorial OR 教程) stars:\u003e1000 after:2023 搜索特点： 在GitHub上搜索 查找高质量教程 限定星标数量 确保资源新鲜度 实例五：求职信息搜索 工作机会搜索： site:(linkedin.com OR zhipin.com) (\"前端开发\" OR \"前端工程师\") (React OR Vue) 深圳 after:2024 搜索策略： 多平台组合 职位名称变体 技术栈要求 地理位置限定 时间限制 参考资料： 文章资料： 36 Google Search tricks to find exactly what you’re looking for How to Google like a Pro – 10 Tips for More Effective Googling Maximize Your Google Search Skills: 10 Surprising Tricks 视频资料 Google Like a Pro – All Advanced Search Operators Tutorial [2023 Tips] https://www.youtube.com/watch?v=C-2YMhMu5Lc\u0026ab_channel=Dave%27sGarage ","date":"2025-01-04","objectID":"/googlesearch/:1:4","tags":["Google","Google Search"],"title":"Google 搜索技巧","uri":"/googlesearch/"},{"categories":["计算机系统课程"],"content":"计算机系统课程","date":"2025-01-26","objectID":"/suchen/","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"左耳朵耗子叔公司小伙伴个人成长经历分享整 【非计算机专业的人如何转行程序员】- 宿琛 视频 bilibili YouTube 公开课资源 1、coursera 课程 2、edx 课程 美国四大计算机名校课程 名校CS课程搜索 Google 检索关键词： Stanford/CMU/MIT/UCB + OS/DB/Networking 1、斯坦福大学 (Stanford University)[https://cs.stanford.edu/] 2、麻省理工大学 (Massachusetts Institute of Technology)[https://www.eecs.mit.edu/research/computer-science/] 3、加州大学 (University of California, Berkeley)[https://www2.eecs.berkeley.edu/Courses/CS/] 4、卡内基梅隆大学 (Carnegie Mellon University)[https://www.cs.cmu.edu/] 个人推荐课程 1、composing programs 2、The Missing Semester of Your CS Education 3、Coursera Data Structures And Algorithms Specialization 课程 4、csapp cmu intro to computer science 5、CMU 15-445/645 Intro to Database Systems 6、MIT 6.S081 7、Stanford CS 144 Introduction to Computer Networking 8、MIT 6.824 分布式系统 推荐书籍 1、精力管理 2、成功，动机与目标 3、深度工作 4、学习之道 ","date":"2025-01-26","objectID":"/suchen/:0:1","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"自学计算机系统课程资源 CS自学指南 CS自救指北 哈佛大学免费的在线课程 MIT的 Introduction to Deep Learning 哈佛大学的 CS 50 斯坦福 cs25 Edx.org上的各大名校的公开课程 小林 x 图解计算机基础 斯坦福大学提供的免费认证课程: Designing Your Career 规划你的职业生涯 Computer Science 101 计算机科学101入门 Algorithms: Design and Analysis, Part 1 算法：设计与分析，第 1 部分 Algorithms: Design and Analysis, Part 2 算法：设计与分析，第 2 部分 Computer and Network Security 计算机和网络安全 Computer Organization and Systems 计算机组成与系统 Databases: Advanced Topics in SQL 数据库：SQL的高级主题 Advanced Cybersecurity Program 高级网络安全课程 Machine Learning Specialization 机器学习专项课程 Introduction to Internet of Things 物联网简介 Introduction to Game Theory 博弈论导论 Introduction to Cryptography 密码学入门 Compilers 编译器入门课程 ","date":"2025-01-26","objectID":"/suchen/:0:2","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"免费的编程中文书籍索引 免费的编程中文书籍索引 ","date":"2025-01-26","objectID":"/suchen/:0:3","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"Teach Yourself Computer Science Teach Yourself Computer Science ","date":"2025-01-26","objectID":"/suchen/:0:4","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"计算机网络 (中科大郑烇、杨坚) 《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》 ","date":"2025-01-26","objectID":"/suchen/:0:5","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"计算机网络 (Ivan Velichko) 图文并茂的计算机网络基础:Computer Networking Fundamentals ","date":"2025-01-26","objectID":"/suchen/:0:6","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"Every Programmer Should Know 🤔 Every Programmer Should Know:包括计算机科学、算法数据结构、分布式、正则、安全、可用性、代码设计、工程哲学等 ","date":"2025-01-26","objectID":"/suchen/:0:7","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"操作系统：设计与实现 (南京大学-蒋炎岩) 视频课程–操作系统：设计与实现 2023 课程主页（含讲义） 视频课程–操作系统：设计与实现 2022 ","date":"2025-01-26","objectID":"/suchen/:0:8","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["计算机系统课程"],"content":"深入架构原理与实践 深入架构原理与实践 ","date":"2025-01-26","objectID":"/suchen/:0:9","tags":["程序员","计算机"],"title":"非计算机专业的人如何转行程序员","uri":"/suchen/"},{"categories":["科技新闻"],"content":"科技新闻","date":"2025-02-16","objectID":"/technologynews/","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"综合科技新闻 Ars Technica – 深入的科技分析，涵盖计算机、科学、汽车等多个领域。 The Verge – 关注消费电子、互联网趋势和新兴科技产品。 TechCrunch – 重点报道初创企业、科技融资、硅谷动态。 Wired – 深入探讨科技对社会的影响，涵盖人工智能、网络安全等领域。 MIT Technology Review – 由麻省理工学院发布，权威科技趋势分析。 **Slashdot– 一个科技新闻聚合网站，用户可以提交和评论新闻，涵盖广泛的科技话题，适合社区互动和讨论。 **The Next Web – 一个科技新闻聚合网站，用户可以提交和评论新闻，涵盖广泛的科技话题，适合社区互动和讨论。 **ZDNet– 关注企业级科技和 IT 行业动态，提供商业科技新闻和分析。 **Techmeme – 一个专注于科技新闻的聚合网站，被称为“科技新闻界的头版”。它通过自动化算法和人工编辑相结合的方式，实时收集和筛选全球范围内的科技新闻、博客文章和社交媒体讨论。 **Engadget – 一家专注于消费电子和科技产品的新闻网站，提供最新的科技新闻、产品评测和行业分析。 ","date":"2025-02-16","objectID":"/technologynews/:0:1","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"编程 \u0026 开发者 Hacker News – 由 Y Combinator 运营，程序员和创业者必看的社区新闻。 Smashing Magazine – 主要关注前端开发、UI/UX 设计。 InfoQ – 软件开发趋势、架构、云计算等领域的专业报道。 ","date":"2025-02-16","objectID":"/technologynews/:0:2","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"科技商业 \u0026 互联网 Bloomberg Technology – 重点关注科技行业的商业动态、公司战略。 Recode by Vox – 深度分析互联网科技企业，如苹果、谷歌、Meta。 CNBC Technology – 关注科技股、市场变动、投资热点。 ","date":"2025-02-16","objectID":"/technologynews/:0:3","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"前沿科技 \u0026 科学探索 Futurism – 关注前沿科技、太空探索、未来趋势。 New Scientist – 深入报道科学与科技的新发现。 Singularity Hub – 关注人工智能、纳米科技、未来医学等突破性技术。 Science Daily – 科学技术新闻，包括生物科技、太空探索、计算机科学等。 ","date":"2025-02-16","objectID":"/technologynews/:0:4","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"网络安全 \u0026 黑客技术 Krebs on Security – 网络安全专家 Brian Krebs 的博客，深入分析网络安全事件。 Dark Reading – 关注网络攻击、漏洞分析、企业安全技术。 Threatpost – 专注于网络安全威胁、漏洞、数据泄露的最新资讯。 ","date":"2025-02-16","objectID":"/technologynews/:0:5","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"AI \u0026 机器学习 AI News – 专注于人工智能领域的最新发展。 Towards Data Science – 机器学习、数据科学的深入讨论和实践经验。 Robohub – 机器人技术、自动化、人工智能研究的最新进展。 IEEE Robotics \u0026 Automation – 机器人学领域的权威资源。 The Robot Report – 机器人产业新闻、产品评测、技术趋势。 ","date":"2025-02-16","objectID":"/technologynews/:0:6","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"电子硬件 \u0026 半导体 \u0026 未来科技 AnandTech – 专注于芯片、处理器、存储设备等硬件评测。 Tom’s Hardware – 计算机硬件、DIY 组装、评测的优质来源。 IEEE Spectrum – 来自 IEEE，涵盖工程、机器人、半导体等前沿科技。 Futurism – 关注前沿科技、太空探索、未来趋势。 New Scientist – 深入报道科学与科技的新发现。 Singularity Hub – 关注人工智能、纳米科技、未来医学等突破性技术。 Science Daily – 科学技术新闻，包括生物科技、太空探索、计算机科学等。 ","date":"2025-02-16","objectID":"/technologynews/:0:7","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"区块链 \u0026 Web3 CoinDesk – 全球领先的加密货币、区块链新闻站点。 The Block – 提供加密行业的深度报道和研究分析。 Decrypt – 关注 Web3、NFT、去中心化金融（DeFi）等技术发展。 ","date":"2025-02-16","objectID":"/technologynews/:0:8","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"自动驾驶 \u0026 未来交通 Electrek – 关注电动汽车（特斯拉）、可再生能源、自动驾驶。 InsideEVs – 提供电动车市场分析、充电技术进展等资讯。 The Drive – 报道汽车科技、无人驾驶、智能交通等前沿趋势。 ","date":"2025-02-16","objectID":"/technologynews/:0:9","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["科技新闻"],"content":"生物科技 \u0026 医疗创新 STAT News – 关注生物科技、医药研发、健康科技。 Medgadget – 医疗设备、AI 医疗、可穿戴健康科技的前沿报道。 GenomeWeb – 专注于基因组学、生物信息学、精准医疗等领域。 你对哪个方向的内容最感兴趣？可以深入推荐更专业的资源！ 😊 ","date":"2025-02-16","objectID":"/technologynews/:0:10","tags":["科技新闻","计算机"],"title":"记录一些优质的科技新闻网站","uri":"/technologynews/"},{"categories":["AI工具","技术笔记"],"content":"全面的AI工具使用指南：从基础对话到高级应用，涵盖编程、写作、设计等各个领域的AI工具推荐和使用技巧。","date":"2025-06-10","objectID":"/ai/","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":" 📝 前言：这是我在使用各种AI工具过程中积累的经验总结，希望能帮助大家更好地利用AI提升工作效率。文章会持续更新，记录最新的工具和使用技巧。 ","date":"2025-06-10","objectID":"/ai/:0:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🤖 AI对话工具详解 ","date":"2025-06-10","objectID":"/ai/:1:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"ChatGPT 系列 ⭐⭐⭐⭐⭐ 官网：https://chat.openai.com 版本对比 GPT-4o：最新版本，多模态能力强，图文并茂 GPT-4：逻辑推理能力最强，适合复杂任务 GPT-3.5：响应速度快，适合日常对话 我的使用心得 💡 最佳实践： 1. 开始对话时先设定角色和背景 2. 复杂任务分解成多个步骤 3. 提供具体例子而非抽象描述 4. 善用\"请继续\"来获取完整回答 实用场景示例 场景一：代码Review 提示词：请以高级程序员的身份，review这段Python代码，重点关注性能优化和安全性问题... 场景二：文案创作 提示词：你是一个资深的新媒体运营，请为我写一篇关于AI工具的推广文案，目标用户是程序员... 场景三：学习助手 提示词：我正在学习机器学习，请用通俗易懂的方式解释什么是神经网络... ","date":"2025-06-10","objectID":"/ai/:1:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Claude 系列 ⭐⭐⭐⭐⭐ 官网：https://claude.ai 核心优势 📖 长文本处理：可以处理100K+ token的文档 🛡️ 安全性高：拒绝生成有害内容 📄 文档分析：支持上传PDF、Word等格式 适用场景 学术论文分析和总结 长篇代码review和重构建议 法律文档、合同条款解读 复杂业务逻辑梳理 ","date":"2025-06-10","objectID":"/ai/:1:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Google Gemini ⭐⭐⭐⭐ 官网：https://gemini.google.com 核心特色 🔍 Google生态集成：与Gmail、Drive、YouTube等服务深度集成 🖼️ 多模态能力：图像分析、文档理解、代码生成 🌍 实时信息：可以搜索最新的网络信息 📱 移动端优化：Android设备原生集成 版本对比 Gemini Ultra：最强性能，与GPT-4竞争 Gemini Pro：平衡性能与成本 Gemini Nano：轻量级，适合移动设备 使用场景 💡 最佳应用场景： - Google Workspace办公自动化 - YouTube视频内容分析 - Android应用开发辅助 - 实时信息查询和分析 - 多语言翻译和本地化 ","date":"2025-06-10","objectID":"/ai/:1:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Grok ⭐⭐⭐⭐ 官网：https://grok.com (需要X Premium订阅) 独特优势 🐦 X平台集成：直接访问X(Twitter)实时数据 😄 幽默风格：具有独特的个性和幽默感 📈 实时资讯：基于X平台的最新信息和趋势 🔓 相对开放：在某些话题上比其他AI更直接 核心功能 🎯 主要特色： 1. 实时热点分析：基于X平台的趋势数据 2. 社交媒体洞察：分析推文和用户行为 3. 新闻事件追踪：快速获取最新资讯 4. 个性化对话：带有马斯克式的幽默风格 使用建议 适合人群：社交媒体运营、新闻工作者、趋势分析师 主要用途：实时信息获取、社交媒体分析、创意写作 注意事项：需要X Premium会员，回答风格较为直接 ","date":"2025-06-10","objectID":"/ai/:1:4","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"国产AI工具对比 工具 优势 适用场景 免费额度 文心一言 中文理解好，百度生态 中文内容创作 每日20次 通义千问 阿里云集成，企业友好 商业应用 每日10次 讯飞星火 语音交互强 语音转文字 每日5次 智谱清言 开源友好 技术研究 每日15次 ","date":"2025-06-10","objectID":"/ai/:1:5","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"💻 AI编程工具实战 ","date":"2025-06-10","objectID":"/ai/:2:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"GitHub Copilot ⭐⭐⭐⭐⭐ 价格：$10/月（学生免费） 进阶使用技巧 注释驱动开发 # 创建一个函数，实现二分查找算法 # 参数：有序数组arr，目标值target # 返回：目标值的索引，如果不存在返回-1 def binary_search(arr, target): # Copilot会自动生成完整实现 测试用例生成 def fibonacci(n): if n \u003c= 1: return n return fibonacci(n-1) + fibonacci(n-2) # 为上面的函数生成测试用例 def test_fibonacci(): # Copilot会生成多个测试场景 代码重构建议 选中代码块，Copilot会提供优化建议 支持多种编程语言和框架 ","date":"2025-06-10","objectID":"/ai/:2:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Cursor ⭐⭐⭐⭐⭐ 官网：https://cursor.sh 独特功能 Ctrl+K：自然语言编程 Ctrl+L：与代码库对话 代码补全：比Copilot更精准的上下文理解 实际使用案例 我的使用场景： 1. 快速生成React组件 2. 代码重构和优化 3. 错误调试和修复 4. API文档生成 ","date":"2025-06-10","objectID":"/ai/:2:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"其他编程AI工具 Tabnine 特点：本地运行，保护代码隐私 适合：企业用户，对安全性要求高 Replit AI 特点：在线IDE + AI辅助 适合：快速原型开发、教学演示 CodeWhisperer (AWS) 特点：AWS服务集成度高 适合：云原生应用开发 ","date":"2025-06-10","objectID":"/ai/:2:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🎨 AI创意工具 ","date":"2025-06-10","objectID":"/ai/:3:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"图像生成工具对比 工具 优势 价格 推荐指数 Midjourney 艺术感强，质量高 $10-60/月 ⭐⭐⭐⭐⭐ DALL-E 3 文字理解准确 $20/月 ⭐⭐⭐⭐ Stable Diffusion 开源免费，可定制 免费 ⭐⭐⭐⭐ Firefly Adobe生态集成 $20/月 ⭐⭐⭐ Midjourney进阶提示词 基础结构：[主题] + [风格] + [参数] 实用模板： - 人像摄影：portrait of [描述], professional photography, studio lighting --ar 3:4 - 产品设计：modern [产品] design, minimalist, white background --ar 1:1 - 概念艺术：[概念] concept art, digital painting, detailed --ar 16:9 高级参数： --ar 16:9 # 宽高比 --v 6 # 版本 --stylize 100 # 风格化程度 --chaos 20 # 随机性 ","date":"2025-06-10","objectID":"/ai/:3:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"视频生成工具 Runway ML 功能：AI视频生成和编辑 特色：Gen-3 Alpha模型，质量接近专业水准 使用场景：短视频制作、广告素材 Pika Labs 功能：文本/图片转视频 特色：操作简单，效果自然 适合人群：内容创作者、社交媒体运营 ","date":"2025-06-10","objectID":"/ai/:3:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"✍️ AI写作工具深度评测 ","date":"2025-06-10","objectID":"/ai/:4:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"长文写作工具 Notion AI 集成优势： 无缝融入工作流 支持多种内容格式 团队协作友好 实用功能： 1. 文章大纲生成：/ai 帮我写一个关于AI工具的文章大纲 2. 内容扩写：选中文字，要求AI扩展内容 3. 语言优化：改善文字表达和语法 4. 格式调整：转换文档格式和风格 Jasper AI 定位：营销文案专家 模板：50+ 营销场景模板 适合：电商、广告、社交媒体 Copy.ai 特色：多语言支持 功能：邮件营销、社交媒体文案 价格：免费版可用，付费$36/月 ","date":"2025-06-10","objectID":"/ai/:4:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"学术写作助手 Grammarly ⭐⭐⭐⭐⭐ 功能亮点： ✅ 语法检查：实时发现并修正错误 ✅ 风格建议：提升文章可读性 ✅ 抄袭检测：确保内容原创性 ✅ 语调分析：调整文章语气 DeepL Write 优势：多语言写作优化 适合：非英语母语用户 功能：句式优化、用词建议 ","date":"2025-06-10","objectID":"/ai/:4:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🚀 提示词工程进阶 ","date":"2025-06-10","objectID":"/ai/:5:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"高级提示词框架 CRISPE 框架 C - Context (上下文)：提供背景信息 R - Role (角色)：指定AI扮演的角色 I - Intent (意图)：明确任务目标 S - Situation (情况)：描述具体场景 P - Product (产品)：定义期望输出 E - Example (示例)：给出参考例子 实际应用案例 【Context】我是一家初创公司的产品经理 【Role】请你作为资深的产品架构师 【Intent】帮我设计一个AI客服系统的产品方案 【Situation】公司有100名员工，日处理客服咨询500+条 【Product】输出包含功能模块、技术架构、实施计划的完整方案 【Example】参考类似ChatBot的设计思路，但要突出我们的差异化优势 ","date":"2025-06-10","objectID":"/ai/:5:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"专业领域提示词库 编程领域 # 代码审查提示词 \"\"\" 请以资深架构师的角度审查以下代码： 1. 代码质量和规范性 2. 性能优化建议 3. 安全性问题 4. 可维护性改进 请提供具体的修改建议和示例代码。 \"\"\" # 算法解析提示词 \"\"\" 请用以下方式解释这个算法： 1. 算法思路（用通俗语言） 2. 时间复杂度分析 3. 空间复杂度分析 4. 适用场景和局限性 5. 代码实现（注释详细） \"\"\" 内容创作 # 文章写作提示词 你是一位专业的科技记者，请按照以下结构写一篇文章： **文章要求：** - 标题：吸引眼球，包含关键词 - 导语：100字内概括核心观点 - 正文：逻辑清晰，数据支撑 - 结尾：总结观点，引发思考 **写作风格：** - 语言简洁明了 - 多用具体数据和案例 - 避免技术术语堆砌 ","date":"2025-06-10","objectID":"/ai/:5:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"Chain of Thought (思维链) 技巧 复杂问题分解 请一步步分析这个商业问题： 步骤1：问题定义 - 明确核心问题是什么 - 涉及哪些关键因素 步骤2：信息收集 - 需要哪些数据支撑 - 现有信息的可靠性 步骤3：方案设计 - 列出3个可行方案 - 分析每个方案的优缺点 步骤4：风险评估 - 识别潜在风险点 - 制定应对策略 步骤5：实施计划 - 制定具体时间表 - 分配资源和责任人 ","date":"2025-06-10","objectID":"/ai/:5:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🎯 AI工具选择策略 ","date":"2025-06-10","objectID":"/ai/:6:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"按使用场景分类 ","date":"2025-06-10","objectID":"/ai/:6:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"主流AI对话工具对比 工具 优势 特色功能 价格 推荐指数 ChatGPT 综合能力强，生态完善 插件系统，代码解释器 $20/月 ⭐⭐⭐⭐⭐ Claude 长文本处理，安全性高 文档分析，代码review $20/月 ⭐⭐⭐⭐⭐ Gemini Google生态，实时搜索 多模态，移动端集成 $20/月 ⭐⭐⭐⭐ Grok 实时资讯，个性化对话 X平台数据，幽默风格 $16/月 ⭐⭐⭐⭐ 个人用户推荐 🏠 日常使用组合： - 主力对话：ChatGPT Plus ($20/月) - 编程助手：GitHub Copilot ($10/月) - 写作优化：Grammarly Premium ($12/月) - 图像生成：Midjourney Basic ($10/月) 💰 总成本：$52/月 💡 性价比：⭐⭐⭐⭐⭐ 🌟 进阶组合（多AI工具）： - 主力对话：ChatGPT + Claude ($40/月) - Google生态：Gemini Pro ($20/月) - 实时资讯：Grok (X Premium $16/月) - 编程助手：GitHub Copilot ($10/月) 💰 高级组合总成本：$86/月 🎯 适合：重度AI用户、专业工作者 企业用户推荐 🏢 团队协作组合： - 团队对话：Claude Pro for Teams - 代码管理：GitHub Copilot Business - 文档协作：Notion AI Team - 设计工具：Adobe Firefly Enterprise ⚡ 重点考虑： - 数据安全和隐私保护 - 团队协作和权限管理 - API接入和定制开发 - 成本控制和使用监控 ","date":"2025-06-10","objectID":"/ai/:6:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"免费工具组合 零成本起步方案 💸 完全免费组合： 1. 对话AI：Claude (免费版) + Gemini (免费版) + 文心一言 2. 编程助手：VS Code + Tabnine (免费版) 3. 写作工具：Grammarly (免费版) + DeepL 4. 图像生成：Stable Diffusion (本地部署) 5. 设计工具：Canva (免费版) 📊 功能覆盖：75%的日常需求 🎯 适合人群：学生、个人爱好者、预算有限用户 💡 免费版限制说明： - Claude：每日有使用次数限制 - Gemini：Google账户即可使用，有一定额度 - Grok：需要X Premium，无免费版 - ChatGPT：GPT-3.5免费，GPT-4需付费 ","date":"2025-06-10","objectID":"/ai/:6:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"⚠️ 使用注意事项与最佳实践 ","date":"2025-06-10","objectID":"/ai/:7:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"数据安全防护 敏感信息分类 🔴 绝对不能输入： - 身份证、银行卡等个人敏感信息 - 公司核心商业机密 - 未公开的产品代码 - 客户隐私数据 🟡 谨慎输入： - 公司内部流程信息 - 正在开发的功能特性 - 团队组织架构 - 业务数据（脱敏后可考虑） 🟢 可以安全输入： - 公开的技术文档 - 学习资料和教程 - 通用的代码片段 - 行业公开信息 隐私保护建议 🛡️ 最佳实践： 1. 使用企业版工具（数据不用于训练） 2. 定期清理对话历史 3. 避免在共享设备上使用 4. 关注各平台隐私政策更新 5. 考虑本地部署开源方案 ","date":"2025-06-10","objectID":"/ai/:7:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"结果验证与质量控制 AI输出质量检查清单 ✅ 代码输出检查： - [ ] 语法正确性 - [ ] 逻辑合理性 - [ ] 性能优化空间 - [ ] 安全漏洞排查 - [ ] 测试用例覆盖 ✅ 文本内容检查： - [ ] 事实准确性验证 - [ ] 逻辑连贯性 - [ ] 语言表达流畅度 - [ ] 原创性（避免抄袭） - [ ] 目标受众适配性 ","date":"2025-06-10","objectID":"/ai/:7:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"持续学习路径 进阶学习资源 📚 推荐学习路径： 初级阶段（1-2个月）： - 掌握基本提示词技巧 - 熟悉主流AI工具界面 - 学会简单的工作流自动化 中级阶段（3-6个月）： - 深入学习提示词工程 - 尝试API集成开发 - 探索多工具组合使用 高级阶段（6个月+）： - 参与开源AI项目 - 开发定制化AI应用 - 成为AI工具布道者 ","date":"2025-06-10","objectID":"/ai/:7:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"🔗 实用资源与社区 ","date":"2025-06-10","objectID":"/ai/:8:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"官方学习资源 OpenAI Cookbook - 官方最佳实践 Anthropic Claude Guide - Claude使用指南 Google AI Education - AI基础知识 Microsoft AI School - 企业AI应用 ","date":"2025-06-10","objectID":"/ai/:8:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"中文社区推荐 AI工具集 - 国内AI工具导航 提示词工程指南 - 中文提示词教程 知乎AI话题 - 经验分享讨论 GitHub Awesome AI - 开源项目集合 ","date":"2025-06-10","objectID":"/ai/:8:2","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"实用工具站点 AI对比平台 - 各AI模型性能对比 提示词库 - 优质提示词分享 AI新闻聚合 - 行业最新动态 ","date":"2025-06-10","objectID":"/ai/:8:3","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术笔记"],"content":"📝 总结与展望 AI工具正在快速发展，新的工具和功能层出不穷。保持学习的心态，关注行业动态，及时调整工具选择策略，才能在AI时代保持竞争优势。 我的使用原则： 🎯 效率优先：选择最能提升工作效率的工具 💰 成本控制：平衡功能需求与经济成本 🔒 安全第一：始终把数据安全放在首位 📈 持续优化：定期评估和调整工具组合 未来展望： AI工具将更加智能化和个性化 多模态AI（文字+图像+语音）成为主流 企业级AI应用将迎来爆发式增长 AI伦理和监管将日趋完善 最后更新：2025年6月 参考链接：SincereCSL/Playgrounds ChatGPT.md 💡 提示：如果你有更好的AI工具推荐或使用技巧，欢迎在评论区分享交流！ ","date":"2025-06-10","objectID":"/ai/:9:0","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI工具使用笔记","uri":"/ai/"},{"categories":["AI工具","技术深度"],"content":"全面解析MCP（Model Context Protocol）：从架构原理到开发实践，探索AI工具的标准化连接协议","date":"2025-06-15","objectID":"/mcp/","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":" 📝 前言：MCP（Model Context Protocol）是由Anthropic发布的开放标准，旨在标准化AI助手与数据源之间的连接方式。本文将深入解析MCP的架构原理、开发模式和实际应用，帮助开发者理解和使用这一革命性的协议。 ","date":"2025-06-15","objectID":"/mcp/:0:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🎯 什么是MCP？ ","date":"2025-06-15","objectID":"/mcp/:1:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"定义与概念 Model Context Protocol (MCP) 是一个开放的协议标准，它标准化了应用程序向大语言模型（LLM）提供上下文的方式。 形象比喻 如果把MCP比作USB-C接口： USB-C：为设备连接各种外设提供标准化接口 MCP：为AI模型连接不同数据源和工具提供标准化协议 ","date":"2025-06-15","objectID":"/mcp/:1:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"核心价值 🎯 MCP解决的核心问题： 1. 数据孤岛：AI模型被困在信息孤岛中 2. 集成复杂：每个数据源需要定制化实现 3. 扩展困难：连接系统难以规模化 4. 维护成本：碎片化集成难以维护 ","date":"2025-06-15","objectID":"/mcp/:1:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🏗️ MCP架构深度解析 ","date":"2025-06-15","objectID":"/mcp/:2:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"整体架构 MCP采用客户端-服务器架构，支持一个宿主应用连接多个服务器： graph TB Host[MCP Host\u003cbr/\u003e宿主应用] --\u003e Client1[MCP Client 1] Host --\u003e Client2[MCP Client 2] Host --\u003e Client3[MCP Client 3] Client1 --\u003e Server1[MCP Server 1\u003cbr/\u003e文件系统] Client2 --\u003e Server2[MCP Server 2\u003cbr/\u003e数据库] Client3 --\u003e Server3[MCP Server 3\u003cbr/\u003eAPI服务] Server1 --\u003e Data1[本地文件] Server2 --\u003e Data2[PostgreSQL] Server3 --\u003e Data3[外部API] ","date":"2025-06-15","objectID":"/mcp/:2:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"核心组件详解 1. MCP Host（宿主） 🏠 定义：运行AI模型的应用程序 📋 功能： - 管理与多个MCP服务器的连接 - 协调AI模型与外部数据的交互 - 处理用户请求和响应 💡 典型示例： - Claude Desktop - VS Code插件 - 自定义AI应用 2. MCP Client（客户端） 🔌 定义：协议客户端，维护与服务器的1:1连接 📋 功能： - 处理协议通信 - 管理连接状态 - 数据序列化/反序列化 🛠️ 实现方式： - 通常内嵌在Host应用中 - 使用官方SDK开发 - 支持多种传输协议 3. MCP Server（服务器） ⚙️ 定义：轻量级程序，通过标准协议暴露特定能力 📋 功能： - 提供Resources（资源） - 暴露Tools（工具） - 实现Prompts（提示模板） 🌟 特点： - 单一职责原则 - 标准化接口 - 易于部署和维护 ","date":"2025-06-15","objectID":"/mcp/:2:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"通信机制 传输层（Transport） { \"jsonrpc\": \"2.0\", \"method\": \"resources/list\", \"id\": 1, \"params\": {} } MCP支持多种传输方式： 标准输入/输出（stdio） # 启动stdio传输的MCP服务器 import sys import asyncio from mcp.server.stdio import stdio_server async def main(): async with stdio_server() as (read_stream, write_stream): await run_server(read_stream, write_stream) if __name__ == \"__main__\": asyncio.run(main()) HTTP传输 # HTTP传输配置 from mcp.server.fastapi import create_mcp_app from fastapi import FastAPI app = FastAPI() mcp_app = create_mcp_app(MyMcpServer()) app.mount(\"/mcp\", mcp_app) # 启动HTTP服务器 if __name__ == \"__main__\": import uvicorn uvicorn.run(app, host=\"0.0.0.0\", port=8000) WebSocket传输 # WebSocket实时通信 import websockets from mcp.server.websocket import websocket_server async def handle_websocket(websocket, path): async with websocket_server(websocket) as server: await server.run() start_server = websockets.serve(handle_websocket, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) 协议消息格式详解 { \"jsonrpc\": \"2.0\", \"method\": \"initialize\", \"id\": 1, \"params\": { \"protocolVersion\": \"2024-11-05\", \"capabilities\": { \"resources\": { \"subscribe\": true, \"listChanged\": true }, \"tools\": { \"listChanged\": true }, \"prompts\": { \"listChanged\": true }, \"logging\": {}, \"sampling\": {} }, \"clientInfo\": { \"name\": \"example-client\", \"version\": \"1.0.0\" } } } ","date":"2025-06-15","objectID":"/mcp/:2:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"💻 MCP核心概念详解 ","date":"2025-06-15","objectID":"/mcp/:3:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"协议生命周期管理 1. 连接建立流程 sequenceDiagram participant Client participant Server Client-\u003e\u003eServer: initialize request Server-\u003e\u003eClient: initialize response Client-\u003e\u003eServer: initialized notification Note over Client,Server: 连接建立完成 Client-\u003e\u003eServer: resources/list Server-\u003e\u003eClient: resources list response Client-\u003e\u003eServer: tools/list Server-\u003e\u003eClient: tools list response Note over Client,Server: 正常通信阶段 2. 能力协商（Capabilities） class ServerCapabilities: def __init__(self): self.resources = ResourceCapabilities( subscribe=True, # 支持资源订阅 listChanged=True # 支持列表变更通知 ) self.tools = ToolCapabilities( listChanged=True # 支持工具列表变更 ) self.prompts = PromptCapabilities( listChanged=True # 支持提示模板变更 ) self.logging = LoggingCapabilities() # 日志功能 self.sampling = SamplingCapabilities() # 采样功能 # 服务器能力声明 async def handle_initialize(self, params): return InitializeResult( protocolVersion=\"2024-11-05\", capabilities=self.get_capabilities(), serverInfo=ServerInfo( name=\"advanced-mcp-server\", version=\"2.0.0\" ) ) ","date":"2025-06-15","objectID":"/mcp/:3:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"1. Resources（资源）深度解析 定义与作用 Resources是MCP服务器暴露给AI模型的只读数据，可以是文件、数据库记录、API响应等。 资源类型系统 from typing import Union, List, Dict, Any from dataclasses import dataclass from enum import Enum class ResourceType(Enum): TEXT = \"text\" BINARY = \"binary\" JSON = \"json\" XML = \"xml\" CSV = \"csv\" IMAGE = \"image\" AUDIO = \"audio\" VIDEO = \"video\" @dataclass class ResourceMetadata: \"\"\"资源元数据\"\"\" size: int lastModified: str encoding: str language: str = None tags: List[str] = None permissions: Dict[str, bool] = None @dataclass class AdvancedResource: uri: str name: str description: str mimeType: str resourceType: ResourceType metadata: ResourceMetadata annotations: Dict[str, Any] = None 高级资源实现 class AdvancedResourceServer(McpServer): def __init__(self): super().__init__(\"advanced-resource-server\") self.resource_cache = {} self.resource_subscribers = set() async def list_resources(self) -\u003e List[AdvancedResource]: \"\"\"列出所有可用资源\"\"\" resources = [] # 动态扫描文件系统 for file_path in self.scan_directory(\"/data\"): resource = await self.create_resource_from_file(file_path) resources.append(resource) # 数据库资源 db_resources = await self.get_database_resources() resources.extend(db_resources) # API资源 api_resources = await self.get_api_resources() resources.extend(api_resources) return resources async def read_resource(self, uri: str) -\u003e Union[str, bytes]: \"\"\"读取资源内容，支持缓存和压缩\"\"\" # 检查缓存 if uri in self.resource_cache: cache_entry = self.resource_cache[uri] if not self.is_cache_expired(cache_entry): return cache_entry['content'] # 根据URI类型读取资源 if uri.startswith(\"file://\"): content = await self.read_file_resource(uri) elif uri.startswith(\"db://\"): content = await self.read_database_resource(uri) elif uri.startswith(\"api://\"): content = await self.read_api_resource(uri) else: raise ValueError(f\"不支持的资源URI: {uri}\") # 更新缓存 self.resource_cache[uri] = { 'content': content, 'timestamp': time.time(), 'size': len(content) if isinstance(content, str) else len(content) } return content async def subscribe_to_resource(self, uri: str) -\u003e None: \"\"\"订阅资源变更通知\"\"\" self.resource_subscribers.add(uri) # 启动文件监控 await self.start_file_watcher(uri) async def notify_resource_changed(self, uri: str): \"\"\"通知资源变更\"\"\" if uri in self.resource_subscribers: await self.send_notification(\"notifications/resources/updated\", { \"uri\": uri, \"timestamp\": time.time() }) 实现示例 # 文件系统资源服务器 from mcp import McpServer, Resource class FileSystemServer(McpServer): async def list_resources(self): return [ Resource( uri=\"file:///path/to/document.txt\", name=\"项目文档\", description=\"项目的详细说明文档\", mimeType=\"text/plain\" ) ] async def read_resource(self, uri: str): if uri.startswith(\"file://\"): path = uri[7:] # 移除file://前缀 with open(path, 'r', encoding='utf-8') as f: return f.read() 应用场景 📁 文件系统： - 代码文件、文档、配置文件 - 支持多种文件格式（txt, md, json, etc.） 🗄️ 数据库： - 表结构、查询结果 - 支持SQL和NoSQL数据库 🌐 Web资源： - API响应、网页内容 - 实时数据抓取 ","date":"2025-06-15","objectID":"/mcp/:3:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"2. Tools（工具）高级特性 定义与作用 Tools允许AI模型执行操作，如文件写入、API调用、数据库更新等。 工具参数验证系统 from pydantic import BaseModel, validator, Field from typing import Optional, Union, List import jsonschema class AdvancedToolParameter(BaseModel): \"\"\"高级工具参数定义\"\"\" name: str type: str description: str required: bool = True default: Optional[Any] = None enum: Optional[List[str]] = None pattern: Optional[str] = None minimum: Optional[Union[int, float]] = None maximum: Optional[Union[int, float]] = None @validator('type') def validate_type(cls, v): valid_types = ['string', 'number', 'integer', 'boolean', 'array', 'object'] if v not in valid_types: raise ValueError(f'Invalid type: {v}') return v class AdvancedTool(BaseModel): \"\"\"高级工具定义\"\"\" name: str description: str parameters: List[AdvancedToolParameter] examples: Optional[List[Dict[str, Any]]] = None category: str = \"general\" tags: List[str] = [] timeout: int = 30 # 超时时间（秒） retryable: bool = True permissions: List[str] = [] def validate_input(self, arguments: Dict[str, Any]) -\u003e None: \"\"\"验证输入参数\"\"\" schema = self.generate_json_schema() try: jsonschema.validate(arguments, schema) except jsonschema.ValidationError as e: raise ValueError(f\"参数验证失败: {e.message}\") def generate_json_schema(self) -\u003e Dict[str, Any]: \"\"\"生成JSON Schema用于参数验证\"\"\" properties = {} required = [] for param in self.parameters: prop = { \"type\": param.type, \"description\": param.description } if param.enum: prop[\"enum\"] = param.enum if param.pattern: prop[\"pattern\"] = param.pattern if param.minimum is not None: prop[\"minimum\"] = param.minimum if param.maximum is not None: prop[\"maximum\"] = param.maximum if param.default is not None: prop[\"default\"] = param.default properties[param.name] = prop if param.required: required.append(param.name) return { \"type\": \"object\", \"properties\": properties, \"required\": required } 工具执行引擎 import asyncio from contextlib import asynccontextmanager import time from typing import AsyncGenerator class ToolExecutionContext: \"\"\"工具执行上下文\"\"\" def __init__(self, tool_name: str, client_id: str): self.tool_name = tool_name self.client_id = client_id self.start_time = time.time() self.execution_id = f\"{tool_name}_{int(time.time())}\" self.metadata = {} class AdvancedToolServer(McpServer): def __init__(self): super().__init__(\"advanced-tool-server\") self.tool_registry = {} self.execution_history = [] self.concurrent_executions = {} def register_tool(self, tool: AdvancedTool, handler_func): \"\"\"注册工具和处理函数\"\"\" self.tool_registry[tool.name] = { 'tool': tool, 'handler': handler_func } async def list_tools(self) -\u003e List[AdvancedTool]: \"\"\"列出所有注册的工具\"\"\" return [entry['tool'] for entry in self.tool_registry.values()] @asynccontextmanager async def execution_context(self, tool_name: str, client_id: str) -\u003e AsyncGenerator[ToolExecutionContext, None]: \"\"\"工具执行上下文管理器\"\"\" context = ToolExecutionContext(tool_name, client_id) self.concurrent_executions[context.execution_id] = context try: yield context finally: # 记录执行历史 context.end_time = time.time() context.duration = context.end_time - context.start_time self.execution_history.append(context) # 清理并发执行记录 del self.concurrent_executions[context.execution_id] async def call_tool(self, name: str, arguments: dict) -\u003e ToolResult: \"\"\"执行工具调用\"\"\" if name not in self.tool_registry: raise McpError( code=ErrorCode.METHOD_NOT_FOUND, message=f\"工具 '{name}' 未找到\" ) tool_entry = self.tool_registry[name] tool = tool_entry['tool'] handler = tool_entry['handler'] # 参数验证 try: tool.validate_input(arguments) except ValueError as e: raise McpError( code=ErrorCode.INVALID_PARAMS, message=str(e) ) # 权限检查 await self.check_tool_permissions(tool, self.get_current_client_id()) # 执行工具 async with self.execution_context(name, self.get_current_client_id()) as context: try: # 设置超时 result = await asyncio.wait_for( handler(arguments, context), timeout=tool.timeout ) return result except asyncio.TimeoutError: raise McpError( code=ErrorCode.REQUEST_TIMEOUT, message=f\"工具执行超时 ({tool.timeout}秒)\" ) except Exception as e: if tool.retryable: # 可重试的工具进行重试 ","date":"2025-06-15","objectID":"/mcp/:3:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"3. Prompts（提示模板） 定义与作用 Prompts是可重用的提示模板，包含动态参数，用于标准化AI交互模式。 实现示例 from mcp import Prompt, PromptArgument class CodeReviewServer(McpServer): async def list_prompts(self): return [ Prompt( name=\"code_review\", description=\"代码评审提示模板\", arguments=[ PromptArgument( name=\"code\", description=\"要评审的代码\", required=True ), PromptArgument( name=\"language\", description=\"编程语言\", required=False ) ] ) ] async def get_prompt(self, name: str, arguments: dict): if name == \"code_review\": code = arguments[\"code\"] language = arguments.get(\"language\", \"未知\") return f\"\"\" 请对以下{language}代码进行详细评审： 代码内容： ```{language} {code} 请从以下几个方面进行分析： 代码质量和规范性 性能优化建议 安全性问题 可维护性改进 最佳实践建议 请提供具体的修改建议和示例代码。 \"\"\" ## 🔒 MCP安全与中间件系统 ### 认证与授权中间件 #### JWT认证中间件 ```python import jwt from functools import wraps from typing import Dict, Any, Optional class JWTAuthMiddleware: def __init__(self, secret_key: str, algorithm: str = \"HS256\"): self.secret_key = secret_key self.algorithm = algorithm def verify_token(self, token: str) -\u003e Optional[Dict[str, Any]]: \"\"\"验证JWT令牌\"\"\" try: payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm]) return payload except jwt.ExpiredSignatureError: raise McpError(code=ErrorCode.UNAUTHORIZED, message=\"令牌已过期\") except jwt.InvalidTokenError: raise McpError(code=ErrorCode.UNAUTHORIZED, message=\"无效令牌\") def require_permission(self, permission: str): \"\"\"权限装饰器\"\"\" def decorator(func): @wraps(func) async def wrapper(self, *args, **kwargs): client_token = self.get_client_token() payload = self.verify_token(client_token) user_permissions = payload.get('permissions', []) if permission not in user_permissions: raise McpError( code=ErrorCode.PERMISSION_DENIED, message=f\"缺少权限: {permission}\" ) return await func(self, *args, **kwargs) return wrapper return decorator class SecureServer(McpServer): def __init__(self): super().__init__(\"secure-server\") self.auth_middleware = JWTAuthMiddleware(os.getenv(\"JWT_SECRET\")) @auth_middleware.require_permission(\"read:resources\") async def read_resource(self, uri: str): return await super().read_resource(uri) @auth_middleware.require_permission(\"execute:tools\") async def call_tool(self, name: str, arguments: dict): return await super().call_tool(name, arguments) 请求限流中间件 import time from collections import defaultdict, deque from typing import DefaultDict class RateLimiter: def __init__(self, max_requests: int, window_seconds: int): self.max_requests = max_requests self.window_seconds = window_seconds self.requests: DefaultDict[str, deque] = defaultdict(deque) def is_allowed(self, client_id: str) -\u003e bool: \"\"\"检查是否允许请求\"\"\" now = time.time() client_requests = self.requests[client_id] # 清理过期请求 while client_requests and client_requests[0] \u003c= now - self.window_seconds: client_requests.popleft() # 检查请求数量 if len(client_requests) \u003e= self.max_requests: return False # 记录新请求 client_requests.append(now) return True class RateLimitedServer(McpServer): def __init__(self): super().__init__(\"rate-limited-server\") self.rate_limiter = RateLimiter(max_requests=100, window_seconds=60) async def handle_request(self, method: str, params: dict): client_id = self.get_current_client_id() if not self.rate_limiter.is_allowed(client_id): raise McpError( code=ErrorCode.RATE_LIMITED, message=\"请求频率超限，请稍后重试\" ) return await super().handle_request(method, params) ","date":"2025-06-15","objectID":"/mcp/:3:4","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"数据加密与脱敏 字段级加密 from cryptography.fernet import Fernet import base64 import json class FieldEncryption: def __init__(self, encryption_key: bytes): self.cipher_suite = Fernet(encryption_key) def encrypt_field(self, data: str) -\u003e str: \"\"\"加密字段\"\"\" encrypted_data = self.cipher_suite.encrypt(data.encode()) return base64.b64encode(encrypted_data).decode() def decrypt_field(self, encrypted_data: str) -\u003e str: \"\"\"解密字段\"\"\" decoded_data = base64.b64decode(encrypted_data.encode()) decrypted_data = self.cipher_suite.decrypt(decoded_data) return decrypted_data.decode() class DataMasking: \"\"\"数据脱敏工具\"\"\" @staticmethod def mask_email(email: str) -\u003e str: \"\"\"邮箱脱敏\"\"\" if '@' not in email: return email local, domain = email.split('@', 1) masked_local = local[:2] + '*' * (len(local) - 2) return f\"{masked_local}@{domain}\" @staticmethod def mask_phone(phone: str) -\u003e str: \"\"\"电话号码脱敏\"\"\" if len(phone) \u003c 7: return phone return phone[:3] + '*' * (len(phone) - 6) + phone[-3:] @staticmethod def mask_id_card(id_card: str) -\u003e str: \"\"\"身份证脱敏\"\"\" if len(id_card) \u003c 8: return id_card return id_card[:4] + '*' * (len(id_card) - 8) + id_card[-4:] class SecureDataServer(McpServer): def __init__(self): super().__init__(\"secure-data-server\") self.field_encryption = FieldEncryption(Fernet.generate_key()) self.data_masking = DataMasking() async def read_resource(self, uri: str) -\u003e str: \"\"\"读取资源并进行数据脱敏\"\"\" raw_data = await self.load_raw_data(uri) # 根据资源类型进行脱敏 if uri.startswith(\"user://\"): return self.mask_user_data(raw_data) elif uri.startswith(\"sensitive://\"): return self.decrypt_and_mask_data(raw_data) return raw_data def mask_user_data(self, data: str) -\u003e str: \"\"\"用户数据脱敏\"\"\" try: user_data = json.loads(data) if 'email' in user_data: user_data['email'] = self.data_masking.mask_email(user_data['email']) if 'phone' in user_data: user_data['phone'] = self.data_masking.mask_phone(user_data['phone']) if 'id_card' in user_data: user_data['id_card'] = self.data_masking.mask_id_card(user_data['id_card']) return json.dumps(user_data, ensure_ascii=False) except json.JSONDecodeError: return data ","date":"2025-06-15","objectID":"/mcp/:3:5","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🔄 MCP协议扩展 ","date":"2025-06-15","objectID":"/mcp/:4:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"自定义协议扩展 class CustomProtocolExtension: \"\"\"自定义协议扩展\"\"\" def __init__(self, namespace: str): self.namespace = namespace self.custom_methods = {} def register_method(self, method_name: str, handler): \"\"\"注册自定义方法\"\"\" full_method_name = f\"{self.namespace}/{method_name}\" self.custom_methods[full_method_name] = handler async def handle_custom_request(self, method: str, params: dict): \"\"\"处理自定义请求\"\"\" if method in self.custom_methods: return await self.custom_methods[method](params) else: raise McpError( code=ErrorCode.METHOD_NOT_FOUND, message=f\"自定义方法未找到: {method}\" ) class ExtendedServer(McpServer): def __init__(self): super().__init__(\"extended-server\") self.extension = CustomProtocolExtension(\"mycompany\") self.setup_custom_methods() def setup_custom_methods(self): \"\"\"设置自定义方法\"\"\" self.extension.register_method(\"bulk_upload\", self.handle_bulk_upload) self.extension.register_method(\"stream_data\", self.handle_stream_data) self.extension.register_method(\"batch_process\", self.handle_batch_process) async def handle_bulk_upload(self, params: dict): \"\"\"处理批量上传\"\"\" files = params.get('files', []) results = [] for file_info in files: result = await self.upload_single_file(file_info) results.append(result) return { \"uploaded\": len(results), \"results\": results } async def handle_stream_data(self, params: dict): \"\"\"处理流数据\"\"\" stream_id = params.get('stream_id') chunk_size = params.get('chunk_size', 1024) async for chunk in self.get_data_stream(stream_id, chunk_size): yield { \"stream_id\": stream_id, \"chunk\": chunk, \"timestamp\": time.time() } ","date":"2025-06-15","objectID":"/mcp/:4:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"事件驱动架构 import asyncio from typing import Callable, List from dataclasses import dataclass @dataclass class McpEvent: \"\"\"MCP事件\"\"\" type: str data: dict timestamp: float source: str class EventBus: \"\"\"事件总线\"\"\" def __init__(self): self.subscribers: Dict[str, List[Callable]] = defaultdict(list) self.event_history: List[McpEvent] = [] def subscribe(self, event_type: str, handler: Callable): \"\"\"订阅事件\"\"\" self.subscribers[event_type].append(handler) def unsubscribe(self, event_type: str, handler: Callable): \"\"\"取消订阅\"\"\" if handler in self.subscribers[event_type]: self.subscribers[event_type].remove(handler) async def publish(self, event: McpEvent): \"\"\"发布事件\"\"\" self.event_history.append(event) # 通知所有订阅者 handlers = self.subscribers.get(event.type, []) if handlers: await asyncio.gather(*[handler(event) for handler in handlers]) def get_event_history(self, event_type: str = None, limit: int = 100) -\u003e List[McpEvent]: \"\"\"获取事件历史\"\"\" events = self.event_history if event_type: events = [e for e in events if e.type == event_type] return events[-limit:] class EventDrivenServer(McpServer): def __init__(self): super().__init__(\"event-driven-server\") self.event_bus = EventBus() self.setup_event_handlers() def setup_event_handlers(self): \"\"\"设置事件处理器\"\"\" self.event_bus.subscribe(\"resource.created\", self.on_resource_created) self.event_bus.subscribe(\"resource.updated\", self.on_resource_updated) self.event_bus.subscribe(\"tool.executed\", self.on_tool_executed) self.event_bus.subscribe(\"client.connected\", self.on_client_connected) async def on_resource_created(self, event: McpEvent): \"\"\"资源创建事件处理\"\"\" resource_uri = event.data.get('uri') await self.send_notification(\"notifications/resources/created\", { \"uri\": resource_uri, \"timestamp\": event.timestamp }) async def on_tool_executed(self, event: McpEvent): \"\"\"工具执行事件处理\"\"\" tool_name = event.data.get('tool_name') execution_time = event.data.get('duration') # 记录性能指标 await self.record_performance_metric(tool_name, execution_time) # 如果执行时间过长，发送警告 if execution_time \u003e 10: # 10秒 await self.send_notification(\"notifications/performance/warning\", { \"tool\": tool_name, \"duration\": execution_time, \"message\": \"工具执行时间过长\" }) ### 分布式MCP架构 #### 服务发现与负载均衡 ```python import consul import hashlib from typing import List, Dict, Optional class ServiceDiscovery: \"\"\"服务发现\"\"\" def __init__(self, consul_host: str = \"localhost\", consul_port: int = 8500): self.consul = consul.Consul(host=consul_host, port=consul_port) self.service_cache = {} self.cache_ttl = 30 # 缓存30秒 async def register_service(self, service_name: str, host: str, port: int, tags: List[str] = None): \"\"\"注册服务\"\"\" service_id = f\"{service_name}-{host}-{port}\" self.consul.agent.service.register( name=service_name, service_id=service_id, address=host, port=port, tags=tags or [], check=consul.Check.http(f\"http://{host}:{port}/health\", interval=\"10s\") ) async def discover_services(self, service_name: str) -\u003e List[Dict]: \"\"\"发现服务\"\"\" # 检查缓存 cache_key = f\"services:{service_name}\" if cache_key in self.service_cache: cached_data = self.service_cache[cache_key] if time.time() - cached_data['timestamp'] \u003c self.cache_ttl: return cached_data['services'] # 从Consul获取服务列表 _, services = self.consul.health.service(service_name, passing=True) service_list = [] for service in services: service_info = service['Service'] service_list.append({ 'id': service_info['ID'], 'address': service_info['Address'], 'port': service_info['Port'], 'tags': service_info['Tags'] }) # 更新缓存 self.service_cache[cache_key] = { 'services': service_list, 'timestamp': time.time() } return service_list class LoadBalancer: \"\"\"负载均衡器\"\"\" def __init__(self, strategy: str = \"round_robin\"): self.strategy = strategy self.round_robin_index = 0 self.service_weights = {} self.service_health = {} def select_service(self, services: List[Dict], client_id: str = None) -\u003e Optional[Dict]: \"\"\"选择服务实例\"\"\" if not services: return None # 过滤健康的服务 healthy_services = [s for s in services if self.service_health.get(s['id'], True)] if not healthy_services: return No","date":"2025-06-15","objectID":"/mcp/:4:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"云原生部署方案 Kubernetes配置 # mcp-server-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: mcp-server labels: app: mcp-server spec: replicas: 3 selector: matchLabels: app: mcp-server template: metadata: labels: app: mcp-server spec: containers: - name: mcp-server image: myregistry/mcp-server:latest ports: - containerPort: 8000 env: - name: DATABASE_URL valueFrom: secretKeyRef: name: mcp-secrets key: database-url - name: REDIS_URL valueFrom: configMapKeyRef: name: mcp-config key: redis-url resources: requests: memory: \"256Mi\" cpu: \"250m\" limits: memory: \"512Mi\" cpu: \"500m\" livenessProbe: httpGet: path: /health port: 8000 initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: httpGet: path: /ready port: 8000 initialDelaySeconds: 5 periodSeconds: 5 --- apiVersion: v1 kind: Service metadata: name: mcp-server-service spec: selector: app: mcp-server ports: - protocol: TCP port: 80 targetPort: 8000 type: LoadBalancer --- apiVersion: autoscaling/v2 kind: HorizontalPodAutoscaler metadata: name: mcp-server-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: mcp-server minReplicas: 2 maxReplicas: 10 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: memory target: type: Utilization averageUtilization: 80 Helm Chart配置 # values.yaml replicaCount: 3 image: repository: myregistry/mcp-server tag: latest pullPolicy: IfNotPresent service: type: LoadBalancer port: 80 targetPort: 8000 ingress: enabled: true annotations: kubernetes.io/ingress.class: nginx cert-manager.io/cluster-issuer: letsencrypt-prod hosts: - host: mcp-api.example.com paths: - path: / pathType: Prefix tls: - secretName: mcp-api-tls hosts: - mcp-api.example.com autoscaling: enabled: true minReplicas: 2 maxReplicas: 10 targetCPUUtilizationPercentage: 70 targetMemoryUtilizationPercentage: 80 resources: limits: cpu: 500m memory: 512Mi requests: cpu: 250m memory: 256Mi # 配置管理 config: database: url: postgresql://user:pass@postgres:5432/mcpdb pool_size: 20 timeout: 30 redis: url: redis://redis:6379/0 ttl: 3600 monitoring: enabled: true prometheus: enabled: true port: 9090 security: jwt_secret: \"your-secret-key\" cors_origins: - \"https://app.example.com\" - \"https://admin.example.com\" ","date":"2025-06-15","objectID":"/mcp/:4:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"高级调试与诊断工具 MCP协议调试器 import json import asyncio from typing import Dict, List, Any from datetime import datetime class McpProtocolDebugger: \"\"\"MCP协议调试器\"\"\" def __init__(self, enable_trace: bool = True): self.enable_trace = enable_trace self.message_history: List[Dict] = [] self.error_history: List[Dict] = [] self.performance_metrics: Dict[str, List] = {} def trace_message(self, direction: str, message: Dict[str, Any]): \"\"\"跟踪消息\"\"\" if not self.enable_trace: return trace_entry = { 'timestamp': datetime.now().isoformat(), 'direction': direction, # 'incoming' 或 'outgoing' 'message': message, 'size': len(json.dumps(message).encode()) } self.message_history.append(trace_entry) # 保持历史记录大小 if len(self.message_history) \u003e 1000: self.message_history = self.message_history[-1000:] def trace_error(self, error: Exception, context: Dict[str, Any] = None): \"\"\"跟踪错误\"\"\" error_entry = { 'timestamp': datetime.now().isoformat(), 'error_type': type(error).__name__, 'error_message': str(error), 'context': context or {} } self.error_history.append(error_entry) if len(self.error_history) \u003e 100: self.error_history = self.error_history[-100:] def record_performance(self, operation: str, duration: float, metadata: Dict = None): \"\"\"记录性能数据\"\"\" if operation not in self.performance_metrics: self.performance_metrics[operation] = [] performance_entry = { 'timestamp': datetime.now().isoformat(), 'duration': duration, 'metadata': metadata or {} } self.performance_metrics[operation].append(performance_entry) # 保持每个操作最多100条记录 if len(self.performance_metrics[operation]) \u003e 100: self.performance_metrics[operation] = self.performance_metrics[operation][-100:] def get_debug_report(self) -\u003e Dict[str, Any]: \"\"\"生成调试报告\"\"\" report = { 'summary': { 'total_messages': len(self.message_history), 'total_errors': len(self.error_history), 'performance_operations': len(self.performance_metrics) }, 'recent_messages': self.message_history[-10:], 'recent_errors': self.error_history[-5:], 'performance_summary': {} } # 性能摘要 for operation, metrics in self.performance_metrics.items(): if metrics: durations = [m['duration'] for m in metrics] report['performance_summary'][operation] = { 'count': len(durations), 'avg_duration': sum(durations) / len(durations), 'min_duration': min(durations), 'max_duration': max(durations) } return report def export_trace(self, filename: str = None): \"\"\"导出跟踪数据\"\"\" if not filename: filename = f\"mcp_trace_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\" trace_data = { 'messages': self.message_history, 'errors': self.error_history, 'performance': self.performance_metrics, 'exported_at': datetime.now().isoformat() } with open(filename, 'w', encoding='utf-8') as f: json.dump(trace_data, f, ensure_ascii=False, indent=2) return filename class DebuggableMcpServer(McpServer): \"\"\"可调试的MCP服务器\"\"\" def __init__(self, name: str, debug_mode: bool = False): super().__init__(name) self.debug_mode = debug_mode self.debugger = McpProtocolDebugger(enable_trace=debug_mode) self.request_id_counter = 0 async def handle_request(self, method: str, params: dict): \"\"\"处理请求（带调试功能）\"\"\" self.request_id_counter += 1 request_id = f\"req_{self.request_id_counter}\" start_time = time.time() # 跟踪入站消息 if self.debug_mode: self.debugger.trace_message('incoming', { 'id': request_id, 'method': method, 'params': params }) try: result = await super().handle_request(method, params) # 跟踪出站响应 if self.debug_mode: self.debugger.trace_message('outgoing', { 'id': request_id, 'result': result }) return result except Exception as e: # 跟踪错误 self.debugger.trace_error(e, { 'request_id': request_id, 'method': method, 'params': params }) # 跟踪错误响应 if self.debug_mode: self.debugger.trace_message('outgoing', { 'id': request_id, 'error': { 'code': getattr(e, 'code', -1), 'message': str(e) } }) raise finally: # 记录性能 duration = time.time() - start_time self.debugger.record_performance(method, duration, { 'request_id': request_id }) async def get_debug_info(self) -\u003e Dict[str, Any]: \"\"\"获取调试信息\"\"\" return self.debugger.get_debug_report() ","date":"2025-06-15","objectID":"/mcp/:4:4","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"智能错误恢复机制 自动故障恢复 import asyncio from typing import Callable, Dict, Any, Optional from enum import Enum class RecoveryStrategy(Enum): \"\"\"恢复策略\"\"\" RETRY = \"retry\" FALLBACK = \"fallback\" CIRCUIT_BREAKER = \"circuit_breaker\" GRACEFUL_DEGRADATION = \"graceful_degradation\" class ErrorRecoveryManager: \"\"\"错误恢复管理器\"\"\" def __init__(self): self.recovery_strategies: Dict[str, RecoveryStrategy] = {} self.fallback_handlers: Dict[str, Callable] = {} self.retry_policies: Dict[str, Dict] = {} self.circuit_breakers: Dict[str, CircuitBreaker] = {} def register_strategy(self, operation: str, strategy: RecoveryStrategy, **kwargs): \"\"\"注册恢复策略\"\"\" self.recovery_strategies[operation] = strategy if strategy == RecoveryStrategy.RETRY: self.retry_policies[operation] = { 'max_attempts': kwargs.get('max_attempts', 3), 'delay': kwargs.get('delay', 1.0), 'backoff_multiplier': kwargs.get('backoff_multiplier', 2.0), 'max_delay': kwargs.get('max_delay', 30.0) } elif strategy == RecoveryStrategy.CIRCUIT_BREAKER: self.circuit_breakers[operation] = CircuitBreaker( failure_threshold=kwargs.get('failure_threshold', 5), timeout=kwargs.get('timeout', 60) ) def register_fallback(self, operation: str, handler: Callable): \"\"\"注册降级处理器\"\"\" self.fallback_handlers[operation] = handler async def execute_with_recovery(self, operation: str, func: Callable, *args, **kwargs): \"\"\"带恢复机制的执行\"\"\" strategy = self.recovery_strategies.get(operation, RecoveryStrategy.RETRY) if strategy == RecoveryStrategy.RETRY: return await self._execute_with_retry(operation, func, *args, **kwargs) elif strategy == RecoveryStrategy.FALLBACK: return await self._execute_with_fallback(operation, func, *args, **kwargs) elif strategy == RecoveryStrategy.CIRCUIT_BREAKER: return await self._execute_with_circuit_breaker(operation, func, *args, **kwargs) elif strategy == RecoveryStrategy.GRACEFUL_DEGRADATION: return await self._execute_with_degradation(operation, func, *args, **kwargs) else: return await func(*args, **kwargs) async def _execute_with_retry(self, operation: str, func: Callable, *args, **kwargs): \"\"\"重试执行\"\"\" policy = self.retry_policies.get(operation, {}) max_attempts = policy.get('max_attempts', 3) delay = policy.get('delay', 1.0) backoff_multiplier = policy.get('backoff_multiplier', 2.0) max_delay = policy.get('max_delay', 30.0) last_exception = None current_delay = delay for attempt in range(max_attempts): try: return await func(*args, **kwargs) except Exception as e: last_exception = e if attempt \u003c max_attempts - 1: await asyncio.sleep(current_delay) current_delay = min(current_delay * backoff_multiplier, max_delay) # 所有重试都失败，抛出最后一个异常 raise last_exception async def _execute_with_fallback(self, operation: str, func: Callable, *args, **kwargs): \"\"\"降级执行\"\"\" try: return await func(*args, **kwargs) except Exception as e: fallback_handler = self.fallback_handlers.get(operation) if fallback_handler: return await fallback_handler(*args, **kwargs) raise e async def _execute_with_circuit_breaker(self, operation: str, func: Callable, *args, **kwargs): \"\"\"熔断器执行\"\"\" circuit_breaker = self.circuit_breakers.get(operation) if not circuit_breaker: return await func(*args, **kwargs) if circuit_breaker.is_open(): raise McpError( code=ErrorCode.SERVICE_UNAVAILABLE, message=f\"服务 {operation} 熔断中\" ) try: result = await func(*args, **kwargs) circuit_breaker.record_success() return result except Exception as e: circuit_breaker.record_failure() raise e async def _execute_with_degradation(self, operation: str, func: Callable, *args, **kwargs): \"\"\"优雅降级执行\"\"\" try: return await func(*args, **kwargs) except Exception as e: # 记录错误但返回降级结果 fallback_handler = self.fallback_handlers.get(operation) if fallback_handler: try: return await fallback_handler(*args, **kwargs) except Exception: # 降级也失败，返回默认值 return self._get_default_response(operation) return self._get_default_response(operation) def _get_default_response(self, operation: str): \"\"\"获取默认响应\"\"\" if operation.startswith('read_'): return \"\" elif operation.startswith('list_'): return [] elif o","date":"2025-06-15","objectID":"/mcp/:4:5","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"多租户支持 租户隔离机制 from typing import Dict, Set, Optional import hashlib class TenantManager: \"\"\"租户管理器\"\"\" def __init__(self): self.tenants: Dict[str, Dict] = {} self.tenant_resources: Dict[str, Set[str]] = {} self.tenant_quotas: Dict[str, Dict] = {} self.tenant_usage: Dict[str, Dict] = {} def create_tenant(self, tenant_id: str, config: Dict): \"\"\"创建租户\"\"\" self.tenants[tenant_id] = { 'id': tenant_id, 'name': config.get('name', tenant_id), 'created_at': time.time(), 'status': 'active', 'config': config } # 初始化资源和配额 self.tenant_resources[tenant_id] = set() self.tenant_quotas[tenant_id] = { 'max_resources': config.get('max_resources', 100), 'max_requests_per_minute': config.get('max_requests_per_minute', 1000), 'max_storage_mb': config.get('max_storage_mb', 1024) } self.tenant_usage[tenant_id] = { 'resources_count': 0, 'requests_count': 0, 'storage_used_mb': 0, 'last_reset': time.time() } def get_tenant(self, tenant_id: str) -\u003e Optional[Dict]: \"\"\"获取租户信息\"\"\" return self.tenants.get(tenant_id) def check_quota(self, tenant_id: str, resource_type: str, amount: int = 1) -\u003e bool: \"\"\"检查配额\"\"\" if tenant_id not in self.tenant_quotas: return False quota = self.tenant_quotas[tenant_id] usage = self.tenant_usage[tenant_id] # 重置每分钟的请求计数 current_time = time.time() if current_time - usage['last_reset'] \u003e= 60: usage['requests_count'] = 0 usage['last_reset'] = current_time if resource_type == 'requests': return usage['requests_count'] + amount \u003c= quota['max_requests_per_minute'] elif resource_type == 'resources': return usage['resources_count'] + amount \u003c= quota['max_resources'] elif resource_type == 'storage': return usage['storage_used_mb'] + amount \u003c= quota['max_storage_mb'] return True def consume_quota(self, tenant_id: str, resource_type: str, amount: int = 1): \"\"\"消费配额\"\"\" if tenant_id not in self.tenant_usage: return usage = self.tenant_usage[tenant_id] if resource_type == 'requests': usage['requests_count'] += amount elif resource_type == 'resources': usage['resources_count'] += amount elif resource_type == 'storage': usage['storage_used_mb'] += amount def get_tenant_namespace(self, tenant_id: str, resource_name: str) -\u003e str: \"\"\"获取租户命名空间的资源名\"\"\" return f\"tenant:{tenant_id}:{resource_name}\" class MultiTenantMcpServer(McpServer): \"\"\"多租户MCP服务器\"\"\" def __init__(self, name: str): super().__init__(name) self.tenant_manager = TenantManager() self.tenant_contexts: Dict[str, str] = {} # 连接ID -\u003e 租户ID映射 async def authenticate_tenant(self, token: str) -\u003e Optional[str]: \"\"\"租户认证\"\"\" # 这里应该实现实际的JWT验证逻辑 # 为简化示例，直接从token中提取租户ID try: # 假设token格式为 \"tenant_id:signature\" tenant_id = token.split(':')[0] if self.tenant_manager.get_tenant(tenant_id): return tenant_id except Exception: pass return None async def handle_request(self, method: str, params: dict): \"\"\"处理多租户请求\"\"\" # 获取当前连接的租户ID connection_id = self.get_current_connection_id() tenant_id = self.tenant_contexts.get(connection_id) if not tenant_id: raise McpError( code=ErrorCode.UNAUTHORIZED, message=\"需要租户认证\" ) # 检查请求配额 if not self.tenant_manager.check_quota(tenant_id, 'requests'): raise McpError( code=ErrorCode.RATE_LIMITED, message=\"租户请求配额已用完\" ) # 消费配额 self.tenant_manager.consume_quota(tenant_id, 'requests') # 在请求参数中注入租户上下文 params['_tenant_id'] = tenant_id return await super().handle_request(method, params) async def read_resource(self, uri: str) -\u003e str: \"\"\"多租户资源读取\"\"\" tenant_id = self._get_current_tenant_id() # 添加租户命名空间 namespaced_uri = self.tenant_manager.get_tenant_namespace(tenant_id, uri) return await super().read_resource(namespaced_uri) async def list_resources(self) -\u003e List[Resource]: \"\"\"列出租户资源\"\"\" tenant_id = self._get_current_tenant_id() # 获取所有资源并过滤租户资源 all_resources = await super().list_resources() tenant_prefix = f\"tenant:{tenant_id}:\" tenant_resources = [] for resource in all_resources: if resource.uri.startswith(tenant_prefix): # 移除租户前缀，返回原始URI original_uri = resource.uri[len(tenant_prefix):] tenant_resources.append(Resource( uri=original_uri, name=resource.name, description=resource.description, mimeType=res","date":"2025-06-15","objectID":"/mcp/:4:6","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🛠️ MCP开发实践 ","date":"2025-06-15","objectID":"/mcp/:5:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"开发环境搭建 1. 安装开发工具 # Python环境 pip install mcp # TypeScript环境 npm install @modelcontextprotocol/sdk # 调试工具 npm install -g @modelcontextprotocol/inspector 2. 项目结构 my-mcp-server/ ├── src/ │ ├── __init__.py │ ├── server.py # 主服务器代码 │ ├── resources.py # 资源处理 │ ├── tools.py # 工具实现 │ └── prompts.py # 提示模板 ├── config/ │ └── server_config.json ├── tests/ │ └── test_server.py ├── requirements.txt └── README.md ","date":"2025-06-15","objectID":"/mcp/:5:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"开发最佳实践 1. 服务器设计原则 from mcp import McpServer from typing import List, Optional import asyncio class BestPracticeServer(McpServer): def __init__(self): super().__init__(\"best-practice-server\") self.name = \"最佳实践服务器\" self.version = \"1.0.0\" async def initialize(self): \"\"\"初始化服务器资源\"\"\" self.logger.info(\"服务器初始化中...\") # 初始化数据库连接、缓存等 async def cleanup(self): \"\"\"清理资源\"\"\" self.logger.info(\"服务器清理中...\") # 关闭连接、清理缓存等 2. 错误处理 from mcp import McpError, ErrorCode async def safe_tool_call(self, name: str, arguments: dict): try: # 工具执行逻辑 result = await self.execute_tool(name, arguments) return result except ValidationError as e: raise McpError( code=ErrorCode.INVALID_PARAMS, message=f\"参数验证失败: {str(e)}\" ) except PermissionError as e: raise McpError( code=ErrorCode.PERMISSION_DENIED, message=\"权限不足\" ) except Exception as e: self.logger.error(f\"工具执行失败: {str(e)}\") raise McpError( code=ErrorCode.INTERNAL_ERROR, message=\"内部服务器错误\" ) 3. 性能优化 import asyncio from functools import lru_cache class OptimizedServer(McpServer): @lru_cache(maxsize=100) async def get_cached_resource(self, uri: str): \"\"\"缓存资源内容\"\"\" return await self.load_resource(uri) async def batch_process_resources(self, uris: List[str]): \"\"\"批量处理资源\"\"\" tasks = [self.get_cached_resource(uri) for uri in uris] return await asyncio.gather(*tasks) ","date":"2025-06-15","objectID":"/mcp/:5:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"调试与测试 1. 使用MCP Inspector # 启动调试工具 npx @modelcontextprotocol/inspector # 测试服务器连接 mcp-inspector --server python my_server.py 2. 单元测试 import pytest from mcp.testing import McpTestClient @pytest.mark.asyncio async def test_resource_listing(): client = McpTestClient(MyMcpServer()) await client.connect() resources = await client.list_resources() assert len(resources) \u003e 0 assert resources[0].name == \"测试资源\" ","date":"2025-06-15","objectID":"/mcp/:5:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🔧 实际应用案例 ","date":"2025-06-15","objectID":"/mcp/:6:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"案例一：代码库分析服务器 需求分析 为AI模型提供代码库的完整上下文，包括文件结构、代码内容、Git历史等。 实现方案 class CodebaseServer(McpServer): def __init__(self, repo_path: str): super().__init__(\"codebase-server\") self.repo_path = repo_path self.git_repo = GitRepository(repo_path) async def list_resources(self): \"\"\"列出代码库中的所有文件\"\"\" files = [] for root, dirs, filenames in os.walk(self.repo_path): for filename in filenames: if self.is_code_file(filename): file_path = os.path.join(root, filename) relative_path = os.path.relpath(file_path, self.repo_path) files.append(Resource( uri=f\"file://{file_path}\", name=relative_path, description=f\"代码文件: {relative_path}\", mimeType=self.get_mime_type(filename) )) return files async def list_tools(self): return [ Tool( name=\"analyze_code_structure\", description=\"分析代码结构和依赖关系\", inputSchema={ \"type\": \"object\", \"properties\": { \"file_pattern\": { \"type\": \"string\", \"description\": \"文件匹配模式\" } } } ), Tool( name=\"get_git_history\", description=\"获取Git提交历史\", inputSchema={ \"type\": \"object\", \"properties\": { \"file_path\": { \"type\": \"string\", \"description\": \"文件路径\" }, \"limit\": { \"type\": \"integer\", \"description\": \"历史记录数量限制\" } } } ) ] ","date":"2025-06-15","objectID":"/mcp/:6:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"案例二：数据库管理服务器 功能特性 数据库连接管理 SQL查询执行 表结构分析 数据安全保护 实现代码 import asyncpg from typing import Dict, Any class DatabaseServer(McpServer): def __init__(self, db_config: Dict[str, Any]): super().__init__(\"database-server\") self.db_config = db_config self.connection_pool = None async def initialize(self): \"\"\"初始化数据库连接池\"\"\" self.connection_pool = await asyncpg.create_pool( **self.db_config, min_size=1, max_size=10 ) async def list_resources(self): \"\"\"列出数据库表和视图\"\"\" async with self.connection_pool.acquire() as conn: tables = await conn.fetch(\"\"\" SELECT table_name, table_type FROM information_schema.tables WHERE table_schema = 'public' \"\"\") return [ Resource( uri=f\"table://{table['table_name']}\", name=table['table_name'], description=f\"数据库{table['table_type']}: {table['table_name']}\", mimeType=\"application/sql\" ) for table in tables ] async def call_tool(self, name: str, arguments: dict): if name == \"execute_query\": query = arguments[\"query\"] # 安全检查 if not self.is_safe_query(query): raise McpError( code=ErrorCode.PERMISSION_DENIED, message=\"查询包含不安全的操作\" ) async with self.connection_pool.acquire() as conn: try: result = await conn.fetch(query) return ToolResult( content=[{ \"type\": \"text\", \"text\": self.format_query_result(result) }] ) except Exception as e: return ToolResult( content=[{ \"type\": \"text\", \"text\": f\"查询执行失败: {str(e)}\" }], isError=True ) def is_safe_query(self, query: str) -\u003e bool: \"\"\"检查查询是否安全\"\"\" dangerous_keywords = [ 'DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE' ] query_upper = query.upper() return not any(keyword in query_upper for keyword in dangerous_keywords) ","date":"2025-06-15","objectID":"/mcp/:6:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"案例三：文档知识库服务器 应用场景 为AI助手提供企业内部文档、知识库的访问能力。 核心实现 from pathlib import Path import markdown from bs4 import BeautifulSoup class KnowledgeBaseServer(McpServer): def __init__(self, docs_path: str): super().__init__(\"knowledge-base-server\") self.docs_path = Path(docs_path) self.doc_index = {} async def initialize(self): \"\"\"构建文档索引\"\"\" await self.build_document_index() async def build_document_index(self): \"\"\"构建文档索引以支持快速搜索\"\"\" for doc_file in self.docs_path.rglob(\"*.md\"): content = doc_file.read_text(encoding='utf-8') # 提取标题和关键词 html = markdown.markdown(content) soup = BeautifulSoup(html, 'html.parser') self.doc_index[str(doc_file)] = { 'title': self.extract_title(soup), 'keywords': self.extract_keywords(content), 'summary': self.generate_summary(content) } async def list_prompts(self): return [ Prompt( name=\"document_qa\", description=\"文档问答提示模板\", arguments=[ PromptArgument( name=\"question\", description=\"用户问题\", required=True ), PromptArgument( name=\"context_docs\", description=\"相关文档\", required=False ) ] ) ] async def get_prompt(self, name: str, arguments: dict): if name == \"document_qa\": question = arguments[\"question\"] context_docs = arguments.get(\"context_docs\", \"\") return f\"\"\" 基于以下文档内容回答用户问题。 相关文档： {context_docs} 用户问题：{question} 请基于文档内容提供准确、详细的回答。如果文档中没有相关信息，请明确说明。 \"\"\" ","date":"2025-06-15","objectID":"/mcp/:6:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🏢 企业级部署方案 ","date":"2025-06-15","objectID":"/mcp/:7:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"部署架构 1. 本地部署 # docker-compose.yml version: '3.8' services: mcp-server: build: . ports: - \"8080:8080\" environment: - DB_HOST=postgres - REDIS_URL=redis://redis:6379 volumes: - ./data:/app/data depends_on: - postgres - redis postgres: image: postgres:15 environment: POSTGRES_DB: mcpdata POSTGRES_USER: mcpuser POSTGRES_PASSWORD: mcppass volumes: - postgres_data:/var/lib/postgresql/data redis: image: redis:7-alpine volumes: postgres_data: 2. 云端部署 # Kubernetes部署示例 kubectl apply -f - \u003c\u003cEOF apiVersion: apps/v1 kind: Deployment metadata: name: mcp-server spec: replicas: 3 selector: matchLabels: app: mcp-server template: metadata: labels: app: mcp-server spec: containers: - name: mcp-server image: my-org/mcp-server:latest ports: - containerPort: 8080 env: - name: DB_HOST value: \"postgres-service\" - name: REDIS_URL value: \"redis://redis-service:6379\" EOF ","date":"2025-06-15","objectID":"/mcp/:7:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"安全最佳实践 1. 认证授权 from functools import wraps import jwt class SecureMcpServer(McpServer): def __init__(self): super().__init__(\"secure-server\") self.jwt_secret = os.getenv(\"JWT_SECRET\") self.authorized_clients = set() def require_auth(self, func): @wraps(func) async def wrapper(*args, **kwargs): client_id = self.get_current_client_id() if client_id not in self.authorized_clients: raise McpError( code=ErrorCode.PERMISSION_DENIED, message=\"未授权的客户端\" ) return await func(*args, **kwargs) return wrapper @require_auth async def call_tool(self, name: str, arguments: dict): # 安全的工具调用 return await super().call_tool(name, arguments) 2. 数据加密 from cryptography.fernet import Fernet class EncryptedDataServer(McpServer): def __init__(self): super().__init__(\"encrypted-server\") self.cipher_suite = Fernet(os.getenv(\"ENCRYPTION_KEY\")) async def read_resource(self, uri: str): \"\"\"读取加密资源\"\"\" encrypted_data = await self.load_encrypted_data(uri) decrypted_data = self.cipher_suite.decrypt(encrypted_data) return decrypted_data.decode('utf-8') ","date":"2025-06-15","objectID":"/mcp/:7:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🚀 未来发展趋势 ","date":"2025-06-15","objectID":"/mcp/:8:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"技术演进方向 1. 协议增强 🔮 未来特性： - 流式数据传输支持 - 更强的类型系统 - 内置缓存机制 - 事务支持 - 更好的错误恢复 2. 生态系统扩展 🌍 生态发展： - 更多预构建服务器 - 可视化配置工具 - 监控和分析平台 - 插件市场 - 企业级管理控制台 3. 与AI Agent集成 # 未来的AI Agent集成示例 class IntelligentMcpAgent: def __init__(self): self.mcp_clients = [] self.reasoning_engine = ReasoningEngine() async def process_request(self, user_request: str): # 1. 分析用户请求 intent = await self.reasoning_engine.analyze_intent(user_request) # 2. 选择合适的MCP服务器 relevant_servers = self.select_servers(intent) # 3. 收集上下文信息 context = await self.gather_context(relevant_servers, intent) # 4. 生成响应 response = await self.generate_response(context, user_request) return response ","date":"2025-06-15","objectID":"/mcp/:8:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"📊 性能优化与监控系统 ","date":"2025-06-15","objectID":"/mcp/:9:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"高级性能监控 实时性能指标收集 import psutil import asyncio from dataclasses import dataclass, asdict from typing import Dict, List import time from collections import deque @dataclass class PerformanceMetrics: \"\"\"性能指标数据结构\"\"\" timestamp: float cpu_usage: float memory_usage: float memory_available: int disk_io_read: int disk_io_write: int network_sent: int network_recv: int active_connections: int response_time: float request_count: int error_count: int class PerformanceMonitor: \"\"\"性能监控器\"\"\" def __init__(self, collection_interval: int = 5): self.collection_interval = collection_interval self.metrics_history: deque = deque(maxlen=1000) # 保留最近1000条记录 self.is_monitoring = False self.thresholds = { 'cpu_usage': 80.0, 'memory_usage': 85.0, 'response_time': 5.0, 'error_rate': 0.05 } self.alerts = [] async def start_monitoring(self): \"\"\"启动监控\"\"\" self.is_monitoring = True while self.is_monitoring: metrics = await self.collect_metrics() self.metrics_history.append(metrics) # 检查告警阈值 await self.check_alerts(metrics) await asyncio.sleep(self.collection_interval) async def collect_metrics(self) -\u003e PerformanceMetrics: \"\"\"收集性能指标\"\"\" # 系统资源指标 cpu_usage = psutil.cpu_percent(interval=1) memory = psutil.virtual_memory() disk_io = psutil.disk_io_counters() network_io = psutil.net_io_counters() # 应用指标 active_connections = await self.get_active_connections() response_time = await self.get_average_response_time() request_count = await self.get_request_count() error_count = await self.get_error_count() return PerformanceMetrics( timestamp=time.time(), cpu_usage=cpu_usage, memory_usage=memory.percent, memory_available=memory.available, disk_io_read=disk_io.read_bytes if disk_io else 0, disk_io_write=disk_io.write_bytes if disk_io else 0, network_sent=network_io.bytes_sent if network_io else 0, network_recv=network_io.bytes_recv if network_io else 0, active_connections=active_connections, response_time=response_time, request_count=request_count, error_count=error_count ) async def check_alerts(self, metrics: PerformanceMetrics): \"\"\"检查告警条件\"\"\" alerts = [] if metrics.cpu_usage \u003e self.thresholds['cpu_usage']: alerts.append({ 'type': 'CPU_HIGH', 'message': f'CPU使用率过高: {metrics.cpu_usage:.2f}%', 'severity': 'WARNING', 'timestamp': metrics.timestamp }) if metrics.memory_usage \u003e self.thresholds['memory_usage']: alerts.append({ 'type': 'MEMORY_HIGH', 'message': f'内存使用率过高: {metrics.memory_usage:.2f}%', 'severity': 'WARNING', 'timestamp': metrics.timestamp }) if metrics.response_time \u003e self.thresholds['response_time']: alerts.append({ 'type': 'RESPONSE_SLOW', 'message': f'响应时间过长: {metrics.response_time:.2f}s', 'severity': 'CRITICAL', 'timestamp': metrics.timestamp }) # 计算错误率 if metrics.request_count \u003e 0: error_rate = metrics.error_count / metrics.request_count if error_rate \u003e self.thresholds['error_rate']: alerts.append({ 'type': 'ERROR_RATE_HIGH', 'message': f'错误率过高: {error_rate:.2%}', 'severity': 'CRITICAL', 'timestamp': metrics.timestamp }) self.alerts.extend(alerts) # 发送告警通知 for alert in alerts: await self.send_alert_notification(alert) def get_metrics_summary(self, duration_minutes: int = 60) -\u003e Dict: \"\"\"获取指标摘要\"\"\" cutoff_time = time.time() - (duration_minutes * 60) recent_metrics = [m for m in self.metrics_history if m.timestamp \u003e= cutoff_time] if not recent_metrics: return {} return { 'avg_cpu_usage': sum(m.cpu_usage for m in recent_metrics) / len(recent_metrics), 'avg_memory_usage': sum(m.memory_usage for m in recent_metrics) / len(recent_metrics), 'avg_response_time': sum(m.response_time for m in recent_metrics) / len(recent_metrics), 'total_requests': sum(m.request_count for m in recent_metrics), 'total_errors': sum(m.error_count for m in recent_metrics), 'error_rate': sum(m.error_count for m in recent_metrics) / max(sum(m.request_count for m in recent_metrics), 1), 'sample_count': len(recent_metrics) } class MonitoredMcpServer(McpServer): \"\"\"带性能监控的MCP服务器\"\"\" def __init__(self): super().__init__(\"monitored-server\") self.performance_monitor = PerformanceMonitor() self.request","date":"2025-06-15","objectID":"/mcp/:9:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"缓存优化策略 多级缓存系统 import redis import pickle from typing import Any, Optional, Union from abc import ABC, abstractmethod class CacheBackend(ABC): \"\"\"缓存后端抽象基类\"\"\" @abstractmethod async def get(self, key: str) -\u003e Optional[Any]: pass @abstractmethod async def set(self, key: str, value: Any, ttl: int = None): pass @abstractmethod async def delete(self, key: str): pass @abstractmethod async def exists(self, key: str) -\u003e bool: pass class MemoryCache(CacheBackend): \"\"\"内存缓存\"\"\" def __init__(self, max_size: int = 1000): self.cache = {} self.max_size = max_size self.access_times = {} async def get(self, key: str) -\u003e Optional[Any]: if key in self.cache: self.access_times[key] = time.time() return self.cache[key] return None async def set(self, key: str, value: Any, ttl: int = None): if len(self.cache) \u003e= self.max_size: # LRU淘汰 oldest_key = min(self.access_times.keys(), key=lambda k: self.access_times[k]) await self.delete(oldest_key) self.cache[key] = value self.access_times[key] = time.time() if ttl: # 设置过期时间 asyncio.create_task(self._expire_key(key, ttl)) async def _expire_key(self, key: str, ttl: int): await asyncio.sleep(ttl) await self.delete(key) async def delete(self, key: str): self.cache.pop(key, None) self.access_times.pop(key, None) async def exists(self, key: str) -\u003e bool: return key in self.cache class RedisCache(CacheBackend): \"\"\"Redis缓存\"\"\" def __init__(self, redis_url: str = \"redis://localhost:6379\"): self.redis = redis.from_url(redis_url, decode_responses=False) async def get(self, key: str) -\u003e Optional[Any]: data = await self.redis.get(key) if data: return pickle.loads(data) return None async def set(self, key: str, value: Any, ttl: int = None): data = pickle.dumps(value) if ttl: await self.redis.setex(key, ttl, data) else: await self.redis.set(key, data) async def delete(self, key: str): await self.redis.delete(key) async def exists(self, key: str) -\u003e bool: return await self.redis.exists(key) class MultiLevelCache: \"\"\"多级缓存系统\"\"\" def __init__(self): self.levels = [ MemoryCache(max_size=100), # L1: 内存缓存 RedisCache(), # L2: Redis缓存 ] async def get(self, key: str) -\u003e Optional[Any]: \"\"\"从缓存获取数据，按级别查找\"\"\" for i, cache in enumerate(self.levels): value = await cache.get(key) if value is not None: # 回填到更高级别的缓存 for j in range(i): await self.levels[j].set(key, value) return value return None async def set(self, key: str, value: Any, ttl: int = None): \"\"\"设置缓存到所有级别\"\"\" for cache in self.levels: await cache.set(key, value, ttl) async def delete(self, key: str): \"\"\"从所有级别删除缓存\"\"\" for cache in self.levels: await cache.delete(key) class CachedMcpServer(McpServer): \"\"\"带缓存的MCP服务器\"\"\" def __init__(self): super().__init__(\"cached-server\") self.cache = MultiLevelCache() self.cache_stats = { 'hits': 0, 'misses': 0, 'sets': 0, 'deletes': 0 } async def read_resource(self, uri: str) -\u003e str: \"\"\"带缓存的资源读取\"\"\" cache_key = f\"resource:{uri}\" # 尝试从缓存获取 cached_data = await self.cache.get(cache_key) if cached_data is not None: self.cache_stats['hits'] += 1 return cached_data # 缓存未命中，从源读取 self.cache_stats['misses'] += 1 data = await super().read_resource(uri) # 存入缓存 await self.cache.set(cache_key, data, ttl=3600) # 1小时过期 self.cache_stats['sets'] += 1 return data def get_cache_stats(self) -\u003e Dict: \"\"\"获取缓存统计\"\"\" total_requests = self.cache_stats['hits'] + self.cache_stats['misses'] hit_rate = self.cache_stats['hits'] / max(total_requests, 1) return { 'hit_rate': hit_rate, 'total_hits': self.cache_stats['hits'], 'total_misses': self.cache_stats['misses'], 'total_sets': self.cache_stats['sets'], 'total_deletes': self.cache_stats['deletes'] } ","date":"2025-06-15","objectID":"/mcp/:9:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"性能调优 1. 连接池管理 import asyncio from contextlib import asynccontextmanager class PooledMcpServer(McpServer): def __init__(self): super().__init__(\"pooled-server\") self.connection_pool = asyncio.Queue(maxsize=10) self.metrics = { 'active_connections': 0, 'total_requests': 0, 'error_count': 0 } @asynccontextmanager async def get_connection(self): \"\"\"获取连接的上下文管理器\"\"\" try: self.metrics['active_connections'] += 1 connection = await self.connection_pool.get() yield connection finally: await self.connection_pool.put(connection) self.metrics['active_connections'] -= 1 2. 请求限流 import time from collections import defaultdict class RateLimitedServer(McpServer): def __init__(self): super().__init__(\"rate-limited-server\") self.request_counts = defaultdict(list) self.rate_limit = 100 # 每分钟100个请求 async def check_rate_limit(self, client_id: str): \"\"\"检查请求频率限制\"\"\" now = time.time() minute_ago = now - 60 # 清理过期记录 self.request_counts[client_id] = [ timestamp for timestamp in self.request_counts[client_id] if timestamp \u003e minute_ago ] # 检查是否超过限制 if len(self.request_counts[client_id]) \u003e= self.rate_limit: raise McpError( code=ErrorCode.RATE_LIMITED, message=\"请求频率过高，请稍后重试\" ) self.request_counts[client_id].append(now) ","date":"2025-06-15","objectID":"/mcp/:9:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"监控体系 1. 指标收集 import time from dataclasses import dataclass from typing import Dict, Any @dataclass class RequestMetrics: method: str duration: float success: bool client_id: str timestamp: float class MonitoredMcpServer(McpServer): def __init__(self): super().__init__(\"monitored-server\") self.metrics: List[RequestMetrics] = [] self.health_status = \"healthy\" async def handle_request(self, method: str, params: Dict[str, Any]): \"\"\"处理请求并收集指标\"\"\" start_time = time.time() client_id = self.get_current_client_id() success = True try: result = await super().handle_request(method, params) return result except Exception as e: success = False raise finally: duration = time.time() - start_time self.metrics.append(RequestMetrics( method=method, duration=duration, success=success, client_id=client_id, timestamp=start_time )) async def get_health_status(self): \"\"\"健康检查端点\"\"\" recent_errors = [ m for m in self.metrics[-100:] # 最近100个请求 if not m.success ] error_rate = len(recent_errors) / min(100, len(self.metrics)) if error_rate \u003e 0.1: # 错误率超过10% self.health_status = \"unhealthy\" else: self.health_status = \"healthy\" return { \"status\": self.health_status, \"error_rate\": error_rate, \"total_requests\": len(self.metrics), \"uptime\": time.time() - self.start_time } ","date":"2025-06-15","objectID":"/mcp/:9:4","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"📚 学习资源与社区 ","date":"2025-06-15","objectID":"/mcp/:10:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"官方资源 MCP官方文档 - 完整的协议规范和开发指南 Anthropic官方博客 - MCP发布公告和技术解读 GitHub仓库 - 官方SDK和示例代码 MCP Inspector - 调试和测试工具 ","date":"2025-06-15","objectID":"/mcp/:10:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"开发工具 Python SDK: pip install mcp TypeScript SDK: npm install @modelcontextprotocol/sdk 调试工具: npm install -g @modelcontextprotocol/inspector ","date":"2025-06-15","objectID":"/mcp/:10:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"社区项目 🔧 实用工具： - MCP服务器模板库 - 可视化配置工具 - 性能监控仪表板 - 自动化测试框架 🌟 开源服务器： - 文件系统服务器 - 数据库连接器 - GitHub集成 - Slack集成 - Google Drive连接器 ","date":"2025-06-15","objectID":"/mcp/:10:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"📝 总结 MCP（Model Context Protocol）作为AI领域的重要技术创新，为构建智能、互联的AI系统提供了标准化的解决方案。通过本文的深入解析，我们了解了： ","date":"2025-06-15","objectID":"/mcp/:11:0","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🎯 核心价值 标准化: 统一AI模型与数据源的连接方式 可扩展: 支持灵活的服务器组合和扩展 安全性: 内置权限控制和数据保护机制 开放性: 开源协议，促进生态发展 ","date":"2025-06-15","objectID":"/mcp/:11:1","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🏗️ 技术特点 简洁的客户端-服务器架构 强大的Resources、Tools、Prompts三大核心概念 灵活的传输协议支持 完善的错误处理机制 ","date":"2025-06-15","objectID":"/mcp/:11:2","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI工具","技术深度"],"content":"🚀 发展前景 MCP将成为AI应用开发的重要基础设施，推动AI工具的标准化和生态化发展。随着更多工具和平台的支持，MCP生态系统将越来越丰富，为开发者和企业提供更强大的AI应用构建能力。 开始你的MCP之旅：从简单的文件系统服务器开始，逐步探索更复杂的应用场景，加入这个激动人心的技术生态！ 参考资料： Anthropic官方MCP介绍 MCP官方文档 MCP GitHub仓库 💡 提示：MCP技术还在快速发展中，建议关注官方更新，及时学习新特性和最佳实践！ ","date":"2025-06-15","objectID":"/mcp/:11:3","tags":["MCP","AI","LLM","Claude","协议","架构"],"title":"深入理解MCP：Model Context Protocol架构解析与开发实践","uri":"/mcp/"},{"categories":["AI资讯","AI"],"content":"了解最新AI前沿资讯信息，关注最新AI发展动向","date":"2025-07-08","objectID":"/ai_01/","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI资讯了解渠道","uri":"/ai_01/"},{"categories":["AI资讯","AI"],"content":"AI资讯渠道 量子位 新智元 AI 日刊 AI今日热榜 — AI资讯聚合网站 linux.do 人工智能模块 Reddit ClaudeAI bensbites 三花快讯 MIT Technology Review – The Algorithm The Verge – AI WIRED – AI ","date":"2025-07-08","objectID":"/ai_01/:0:1","tags":["AI","LLM","ChatGPT","Copilot","提示词工程"],"title":"我的AI资讯了解渠道","uri":"/ai_01/"},{"categories":null,"content":"✋ Hi，小伙伴们你们好呀！我是 SincereCSL 一名前端开发工程师，热爱探索新技术，喜欢在空间时间中学习与沉淀。 技术狂热爱好者，喜欢逛 Hacker News、TechCrunch、GitHub、Stack Overflow、YouTube 等技术社区，持续学习前沿技术。在 GitHub 开源社区积极分享技术成果，乐于钻研、实践并推动技术创新。热爱 阅读、篮球，以技术驱动成长，持续突破自我。 希望不断学习，不断成长。期望能在忙碌中持续提升自己，写好每一行代码，过好每一天。 现阶段的目标是能够在忙碌地闲隙里多学习、不断思考，多阅读写作。 ","date":"2023-01-11","objectID":"/about/:1:0","tags":null,"title":"关于 SincereCSL","uri":"/about/"},{"categories":null,"content":"📡 个人网络信息 Email： SincerestCSL@gmail.com Twitter GitHub 豆瓣书单 ","date":"2023-01-11","objectID":"/about/:1:1","tags":null,"title":"关于 SincereCSL","uri":"/about/"},{"categories":null,"content":"👨‍💻 个人简介 我是一名前端开发工程师，拥有 7 年 Web 前端开发经验，熟练掌握主流前端技术与工程化工具，具备从 0 到 1 独立完成项目的能力，也擅长协作与推动项目高质量上线交付。拥有广泛的技术知识和实践经验并有丰富的项目实践经验。我深入理解这些框架的核心原理和工作机制，可以独立地设计和构建复杂的前端应用程序。 🔧 技术栈 语言与核心技术：JavaScript、TypeScript、HTML5、CSS3、Sass、Less 框架与类库：Vue3、Vue2、React16+、UmiJS、AngularJS（1.x）、jQuery UI 框架：Element Plus、Element UI、Ant Design、Bootstrap 等 构建工具与工程化：Webpack、Vite、ESLint、Prettier、Stylelint、MockJS 后端基础能力：Node.js、Go、MongoDB、MySQL、Docker 跨平台桌面开发：了解 CEF 框架，掌握 JS 与 C++ 的交互机制 图形图像与可视化(感兴趣)：WebGL、WebGPU、Canvas、SVG、CesiumJS（三维可视化） 🧠 项目经验与优势 熟悉组件化开发、响应式设计、模块化与规范化流程 能快速搭建前端开发体系，提升团队开发效率与代码质量 熟悉业务系统开发与维护，参与多个核心平台前端架构设计 擅长构建大屏可视化展示平台与数据图表系统 具备一定的后端协作与系统理解能力，便于快速集成上线 ","date":"2023-01-11","objectID":"/about/:1:2","tags":null,"title":"关于 SincereCSL","uri":"/about/"},{"categories":null,"content":"✅ 能力总结 注重代码质量与开发规范，熟悉团队协作流程 善于知识分享，具备较强文档编写与技术表达能力 喜欢钻研底层原理，追求性能优化与可维护性 热衷学习新技术，具备持续学习与快速上手能力 希望能在未来的技术旅程中，与更多优秀的伙伴一起成长，一起打造出更有温度的产品与技术成果！ 关于本站 主要用来记录我自己学习、生活与零碎的一些想法。基于稳定性和自由度考虑决定使用 Hugo 生 成自己的静态网页，托管于 GitHub。SincereCSL 的名字是我个人比较喜欢的一个单词Sincere与我的中文名首字母组合起来的， 希望每天都提醒着自己真诚地对待每位人和世界，坦率地去做自己喜欢的事，不断去学习、体验与挑战新的事物，提升自己。 希望自己能多输入一些新的知识和想法，多写一些小文章。 ","date":"2023-01-11","objectID":"/about/:1:3","tags":null,"title":"关于 SincereCSL","uri":"/about/"},{"categories":null,"content":"时不时更新中👀 … ","date":"2022-02-27","objectID":"/links/:0:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"博客 Martin Fowler The Clean Code Blog Joel on Software Paul Graham Essays Julia Evans 酷壳 – CoolShell 阮一峰的个人网站 面向信仰编程 冰霜之地 当然我在扯淡 宝玉的分享 justjavac(迷渡) 小胡子哥的个人网站 勾三股四 是不是很酷:微信公众号 张鑫旭-鑫空间-鑫生活 ","date":"2022-02-27","objectID":"/links/:1:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"文章 40 years of programming 别让自己“墙”了自己 如何超过大多数人 Teach Yourself Programming in Ten Years What are some of the most basic things every programmer should know? how to read an academic article How To Ask Questions The Smart Way ","date":"2022-02-27","objectID":"/links/:2:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"英语 BBC Learning English 英语自学 英语进阶指南 人人都能用英语-李笑来 ","date":"2022-02-27","objectID":"/links/:3:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"英语播客 以下是一些专为初学者设计的英语播客，语速较慢且内容简单易懂： 6 Minute English - BBC制作的简短英语学习节目，每集仅6分钟，针对初中级学习者，内容通俗易懂 The English We Speak - BBC出品，专注于日常英语短语和俚语学习，每集3-4分钟，非常适合初学者 ESLPod - 专为英语学习者设计的播客，语速缓慢且解释详细，对初学者非常友好 Speak English Now - 通过有趣的故事和对话帮助学习者自然地学习英语，强调听力输入 All Ears English - 轻松有趣的英语学习播客，专注于日常实用对话和美国文化，设有专门的初学者内容 Coffee Break English - 短小精悍的英语学习节目，像喝咖啡休息一样轻松学习英语，分级教学 Elementary Podcasts - 英国文化协会出品，专为初学者设计的对话和故事，配有完整文字稿 以下是一些优质英语播客，非常适合提升英语听力和学习地道表达： Luke’s ENGLISH Podcast - 由英语老师Luke主持，通过轻松有趣的方式教授英语表达和文化，适合中高级学习者 This American Life - 美国国宝级广播节目，每期围绕一个主题讲述多个真实故事，语速适中，表达地道 Lex Fridman Podcast - MIT研究员主持的深度访谈节目，邀请科技、科学、艺术等领域的顶尖人物对话 The Tim Ferriss Show - 畅销书作家蒂姆·费里斯访谈各行业精英，解析成功经验和生活习惯 Up First from NPR - NPR每日新闻摘要，10-15分钟了解全球重要事件，语速适中清晰 Serial - 沉浸式叙事调查性节目，每季深入剖析一个真实故事，叙事性强 Planet Money - 用生动方式解释复杂经济概念，故事性强，适合各级别学习者 TED Talks Daily - 每日更新TED演讲，涵盖广泛话题，多数演讲语速适中 The Allusionist - 探索语言起源和演变的有趣节目，适合对语言学感兴趣的学习者 Grammar Girl - 简短实用的英语语法和写作技巧，特别适合想提高写作的学习者 ","date":"2022-02-27","objectID":"/links/:4:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"程序员相关播客 Web Worker-前端程序员都爱听 硬地骇客 浪说播客 代码之外 Beyond code Lex Fridman Podcast JS Party: JavaScript, CSS, Web Development The Changelog: Software Development, Open Source CoRecursive: Coding Stories Serial This Is Actually Happening This American Life The Indicator from Planet Money ","date":"2022-02-27","objectID":"/links/:5:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"写作 Technical Writing Courses: Google 技术文档的课程 The Day You Became A Better Writer ","date":"2022-02-27","objectID":"/links/:6:0","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"工具 Language Reactor 一款可以加载双语字幕的插件 Bypass Paywalls Clean 【Chrome、Firefox插件】支持多达 500+网站的付费墙绕过，默认包括南方周末，路透社，经济学人，纽约时报，华尔街日报等大部分主流媒体。 Relingo 可以将自己不懂生词和难词，自动标示和翻译 Trancy 支持YouTube、NetFlix双语字幕、字幕阅读模式、划词翻译 Medium Parser Chrome 插件 可以绕过 Medium 的付费墙 查看付费文章 ","date":"2022-02-27","objectID":"/links/:7:0","tags":null,"title":"Links","uri":"/links/"}]